<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Mylène Husson" />


<title>Journal 1</title>

<script src="site_libs/header-attrs-2.29/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/clipboard-1.7.1/clipboard.min.js"></script>
<link href="site_libs/primer-tooltips-1.4.0/build.css" rel="stylesheet" />
<link href="site_libs/klippy-0.0.0.9500/css/klippy.min.css" rel="stylesheet" />
<script src="site_libs/klippy-0.0.0.9500/js/klippy.min.js"></script>
<link href="site_libs/font-awesome-6.5.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    My journal
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="lab1.html">Week 1</a>
    </li>
    <li>
      <a href="lab2.html">Week 2</a>
    </li>
    <li>
      <a href="lab3.html">Week 3</a>
    </li>
    <li>
      <a href="lab4.html">Week 4</a>
    </li>
    <li>
      <a href="lab5.html">Week 5a</a>
    </li>
    <li>
      <a href="lab5tryouts.html">Week 5b</a>
    </li>
    <li>
      <a href="Create_dataset.html">Week 5c</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://mcmhusson.github.io/labjournal_mylene/">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Journal 1</h1>
<h4 class="author">Mylène Husson</h4>

</div>


<pre class="r"><code>library(knitr)
library(tidyverse)
library(scholar)
library(openalexR)
library(rvest)
library(jsonlite)
library(httr)
library(rvest)
library(reshape2)
library(xml2)
library(openxlsx)
library(polite)
library(igraph)
library(sna)
library(genderizeR)
library(RSelenium)
library(netstat)
library(pingr)
library(RSiena)
library(devtools)
library(RsienaTwoStep)


# load the functions you need from the packages
fpackage.check &lt;- function(packages) {
  lapply(packages, FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  })
}

fsave &lt;- function(x, file = NULL, location = &quot;./data/processed/&quot;) {
  ifelse(!dir.exists(&quot;data&quot;), dir.create(&quot;data&quot;), FALSE)
  ifelse(!dir.exists(&quot;data/processed&quot;), dir.create(&quot;data/processed&quot;), FALSE)
  
  if (is.null(file)) {
    file &lt;- deparse(substitute(x))
  }
  
  datename &lt;- substr(gsub(&quot;[:-]&quot;, &quot;&quot;, Sys.time()), 1, 8)
  totalname &lt;- paste(location, datename, file, &quot;.rda&quot;, sep = &quot;&quot;)
  save(x, file = totalname)  # need to fix if file is reloaded as input name, not as x.
}

fload &lt;- function(filename) {
  load(filename)
  get(ls()[ls() != &quot;filename&quot;])
}

fshowdf &lt;- function(x, ...) {
  knitr::kable(x, digits = 2, &quot;html&quot;, ...) %&gt;%
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;)) %&gt;%
    kableExtra::scroll_box(width = &quot;100%&quot;, height = &quot;300px&quot;)
}</code></pre>
<script>
  addClassKlippyTo("pre.r, pre.markdown");
  addKlippy('right', 'top', 'auto', '1', 'Copy code', 'Copied!');
</script>
<p>Last compiled on October, 2025 <br></p>
<hr />
<div id="create-dataset" class="section level2" number="1">
<h2><span class="header-section-number">1</span> Create Dataset</h2>
<p><br></p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">### Genderize function</td>
</tr>
<tr class="even">
<td align="left">``` r my_genderizer &lt;- function(name) { name &lt;-
gsub(“^/+|/+$”, ““, name)</td>
</tr>
<tr class="odd">
<td align="left"># Build URL base_url &lt;- “<a
href="https://nvb.meertens.knaw.nl/naam/is"
class="uri">https://nvb.meertens.knaw.nl/naam/is</a>” name_url &lt;-
paste0(base_url, “/”, name)</td>
</tr>
<tr class="even">
<td align="left"># Try reading table table &lt;- tryCatch(
read_html(name_url) |&gt; html_element(“table”) |&gt; html_table(),
error = function(e) NULL )</td>
</tr>
<tr class="odd">
<td align="left">if (is.null(table)) return(NA) # return NA if no table
found</td>
</tr>
<tr class="even">
<td align="left"># Replace “–” with “0” table[table == “–”] &lt;-
“0”</td>
</tr>
<tr class="odd">
<td align="left"># Convert to numeric val_male &lt;-
suppressWarnings(as.numeric(table[2, 3])) val_female &lt;-
suppressWarnings(as.numeric(table[6, 3]))</td>
</tr>
<tr class="even">
<td align="left"># Decide gender if (is.na(val_male) &amp;
is.na(val_female)) { gender &lt;- NA } else if (val_male &gt;
val_female) { gender &lt;- “male” } else if (val_female &gt; val_male) {
gender &lt;- “female” } else { gender &lt;- NA }</td>
</tr>
<tr class="odd">
<td align="left">return(gender) } ``` <br> ### Load the data</td>
</tr>
<tr class="even">
<td align="left">``` r # load in the data scholars &lt;-
fload(“./data/processed/scholars_20240924.rda”)</td>
</tr>
<tr class="odd">
<td align="left"># select scholars # (sociology, RU) demographics &lt;-
do.call(rbind.data.frame, scholars$demographics) demographics &lt;-
demographics %&gt;% mutate(Universiteit1.22 = replace(Universiteit1.22,
is.na(Universiteit1.22), ““), Universiteit2.22 =
replace(Universiteit2.22, is.na(Universiteit2.22),”“), Universiteit1.24
= replace(Universiteit1.24, is.na(Universiteit1.24),”“),
Universiteit2.24 = replace(Universiteit2.24,
is.na(Universiteit2.24),”“), discipline.22 = replace(discipline.22,
is.na(discipline.22),”“), discipline.24 = replace(discipline.24,
is.na(discipline.24),”“))</td>
</tr>
<tr class="even">
<td align="left">sample &lt;- which((demographics<span
class="math inline">\(Universiteit1.22 == &quot;RU&quot; |
demographics\)</span>Universiteit2.22 == “RU” | demographics<span
class="math inline">\(Universiteit1.24 ==
&quot;RU&quot; | demographics\)</span>Universiteit2.24 == “RU”) &amp;
(demographics<span class="math inline">\(discipline.22 ==
&quot;sociology&quot; | demographics\)</span>discipline.24 ==
“sociology”))</td>
</tr>
<tr class="odd">
<td align="left">demographics_soc &lt;- demographics[sample, ]
scholars_sel &lt;- lapply(scholars, “[”, sample)</td>
</tr>
<tr class="even">
<td align="left"># construct the empty adjacency matrix ids &lt;-
demographics_soc$au_id wave2 &lt;- wave1 &lt;- matrix(0, nrow =
length(ids), ncol = length(ids), dimnames = list(ids, ids))</td>
</tr>
<tr class="odd">
<td align="left"># filter works works &lt;- scholars_sel$work</td>
</tr>
<tr class="even">
<td align="left">works_id &lt;- unlist(lapply(works, function(l) l<span
class="math inline">\(id))
works_author &lt;- unlist(lapply(works, function(l) l\)</span>author),
recursive = FALSE) works_year &lt;- unlist(lapply(works, function(l)
l$publication_year), recursive = FALSE)</td>
</tr>
<tr class="odd">
<td align="left">df_works &lt;- tibble(works_id, works_author,
works_year)</td>
</tr>
<tr class="even">
<td align="left">dups &lt;- which(duplicated(works_id))</td>
</tr>
<tr class="odd">
<td align="left">df_works &lt;- df_works[-dups, ] df_works_w2 &lt;-
df_works[df_works$works_year &gt; 2019, ]</td>
</tr>
<tr class="even">
<td align="left"># undirected # undirected for (i in
1:nrow(df_works_w2)) { egos &lt;- df_works_w2<span
class="math inline">\(works_author[i][[1]]\)</span>au_id</td>
</tr>
<tr class="odd">
<td align="left">if (sum(ids %in% egos) &gt; 0) { wave2[which(ids %in%
egos), which(ids %in% egos)] &lt;- 1 } }</td>
</tr>
<tr class="even">
<td align="left">fcolnet &lt;- function(data = scholars, university =
“RU”, discipline = “sociology”, waves = list(c(2015, 2018), c(2019,
2023)), type = c(“first”)) {</td>
</tr>
<tr class="odd">
<td align="left"># step 1 demographics &lt;- do.call(rbind.data.frame,
data$demographics) demographics &lt;- demographics %&gt;%
mutate(Universiteit1.22 = replace(Universiteit1.22,
is.na(Universiteit1.22), ““), Universiteit2.22 =
replace(Universiteit2.22, is.na(Universiteit2.22),”“), Universiteit1.24
= replace(Universiteit1.24, is.na(Universiteit1.24),”“),
Universiteit2.24 = replace(Universiteit2.24,
is.na(Universiteit2.24),”“), discipline.22 = replace(discipline.22,
is.na(discipline.22),”“), discipline.24 = replace(discipline.24,
is.na(discipline.24),”“))</td>
</tr>
<tr class="even">
<td align="left">sample &lt;- which((demographics<span
class="math inline">\(Universiteit1.22 %in% university |
demographics\)</span>Universiteit2.22 %in% university |
demographics<span class="math inline">\(Universiteit1.24 %in% university
| demographics\)</span>Universiteit2.24 %in% university) &amp;
(demographics<span class="math inline">\(discipline.22 %in% discipline |
demographics\)</span>discipline.24 %in% discipline))</td>
</tr>
<tr class="odd">
<td align="left">demographics_soc &lt;- demographics[sample, ]
scholars_sel &lt;- lapply(scholars, “[”, sample)</td>
</tr>
<tr class="even">
<td align="left"># step 2 ids &lt;- demographics_soc$au_id nwaves &lt;-
length(waves) nets &lt;- array(0, dim = c(nwaves, length(ids),
length(ids)), dimnames = list(wave = 1:nwaves, ids, ids))
dimnames(nets)</td>
</tr>
<tr class="odd">
<td align="left"># step 3 df_works &lt;- tibble(works_id =
unlist(lapply(scholars_sel<span class="math inline">\(work, function(l)
l\)</span>id)), works_author = unlist(lapply(scholars_sel<span
class="math inline">\(work,
function(l) l\)</span>author), recursive = FALSE), works_year =
unlist(lapply(scholars_sel<span class="math inline">\(work, function(l)
l\)</span>publication_year), recursive = FALSE))</td>
</tr>
<tr class="even">
<td align="left">df_works &lt;- df_works[!duplicated(df_works), ]</td>
</tr>
<tr class="odd">
<td align="left"># step 4 if (type == “first”) { for (j in 1:nwaves) {
df_works_w &lt;- df_works[df_works<span class="math inline">\(works_year
&gt;= waves[[j]][1] &amp; df_works\)</span>works_year &lt;=
waves[[j]][2],] for (i in 1:nrow(df_works_w)) { ego &lt;-
df_works_w<span
class="math inline">\(works_author[i][[1]]\)</span>au_id[1] alters &lt;-
df_works_w<span
class="math inline">\(works_author[i][[1]]\)</span>au_id[-1] if (sum(ids
%in% ego) &gt; 0 &amp; sum(ids %in% alters) &gt; 0) { nets[j, which(ids
%in% ego), which(ids %in% alters)] &lt;- 1 } } } }</td>
</tr>
<tr class="even">
<td align="left">if (type == “last”) { for (j in 1:nwaves) { df_works_w
&lt;- df_works[df_works<span class="math inline">\(works_year &gt;=
waves[[j]][1] &amp; df_works\)</span>works_year &lt;= waves[[j]][2],]
for (i in 1:nrow(df_works_w)) { ego &lt;- rev(df_works_w<span
class="math inline">\(works_author[i][[1]]\)</span>au_id)[1] alters
&lt;- rev(df_works_w<span
class="math inline">\(works_author[i][[1]]\)</span>au_id)[-1] if
(sum(ids %in% ego) &gt; 0 &amp; sum(ids %in% alters) &gt; 0) { nets[j,
which(ids %in% ego), which(ids %in% alters)] &lt;- 1 } } } }</td>
</tr>
<tr class="odd">
<td align="left">if (type == “all”) { for (j in 1:nwaves) { df_works_w
&lt;- df_works[df_works<span class="math inline">\(works_year &gt;=
waves[[j]][1] &amp; df_works\)</span>works_year &lt;= waves[[j]][2],]
for (i in 1:nrow(df_works_w)) { egos &lt;- df_works_w<span
class="math inline">\(works_author[i][[1]]\)</span>au_id if (sum(ids
%in% egos) &gt; 0) { nets[j, which(ids %in% egos), which(ids %in% egos)]
&lt;- 1 } } } } output &lt;- list() output<span
class="math inline">\(data &lt;- scholars_sel
output\)</span>nets &lt;- nets return(output) }</td>
</tr>
<tr class="even">
<td align="left">df_scholars &lt;- do.call(rbind, scholars$demographics)
``` <br> ### Attach gender</td>
</tr>
<tr class="odd">
<td align="left">``` r df_scholars_gender &lt;- df_scholars |&gt;
mutate(firstname = word(Naam, 1)) # extract first names</td>
</tr>
<tr class="even">
<td align="left">df_scholars_gender$gender &lt;- NA_character_ #
initialize gender column</td>
</tr>
<tr class="odd">
<td align="left">for (i in seq_len(nrow(df_scholars_gender))) { name
&lt;- df_scholars_gender$firstname[i] gender &lt;-
my_genderizer(name)</td>
</tr>
<tr class="even">
<td align="left">df_scholars_gender$gender[i] &lt;- gender
Sys.sleep(0.06) # pause between requests } ``` <br> ### Big data</td>
</tr>
<tr class="odd">
<td align="left">``` r fcolnet_gender &lt;- function(data = scholars,
waves = list(c(2015, 2018), c(2019, 2023)), type = “first”, demographics
= NULL) {</td>
</tr>
<tr class="even">
<td align="left"># ————————- # Step 1: demographics # ————————- if
(is.null(demographics)) { demographics &lt;- do.call(rbind.data.frame,
data$demographics) }</td>
</tr>
<tr class="odd">
<td align="left">demographics &lt;- demographics %&gt;% mutate(
Universiteit1.22 = replace(Universiteit1.22, is.na(Universiteit1.22),
““), Universiteit2.22 = replace(Universiteit2.22,
is.na(Universiteit2.22),”“), Universiteit1.24 =
replace(Universiteit1.24, is.na(Universiteit1.24),”“), Universiteit2.24
= replace(Universiteit2.24, is.na(Universiteit2.24),”“), discipline.22 =
replace(discipline.22, is.na(discipline.22),”“), discipline.24 =
replace(discipline.24, is.na(discipline.24),”“) )</td>
</tr>
<tr class="even">
<td align="left"># ————————- # select all scholars # ————————- sample
&lt;- seq_len(nrow(demographics))</td>
</tr>
<tr class="odd">
<td align="left">demographics_all &lt;- demographics[sample, ]
scholars_sel &lt;- lapply(data, “[”, sample)</td>
</tr>
<tr class="even">
<td align="left"># ————————- # Step 2: initialize network array #
————————- ids &lt;- demographics_all$au_id nwaves &lt;- length(waves)
nets &lt;- array( 0, dim = c(nwaves, length(ids), length(ids)), dimnames
= list(wave = 1:nwaves, ids, ids) )</td>
</tr>
<tr class="odd">
<td align="left"># ————————- # Step 3: works dataframe # ————————-
df_works &lt;- tibble( works_id = unlist(lapply(scholars_sel<span
class="math inline">\(work, function(l) if(!is.null(l)) l\)</span>id
else NA)), works_author = unlist(lapply(scholars_sel<span
class="math inline">\(work, function(l) if(!is.null(l)) l\)</span>author
else NA), recursive = FALSE), works_year =
unlist(lapply(scholars_sel<span class="math inline">\(work, function(l)
if(!is.null(l)) l\)</span>publication_year else NA), recursive = FALSE)
) %&gt;% filter(!is.na(works_id))</td>
</tr>
<tr class="even">
<td align="left">df_works &lt;- df_works[!duplicated(df_works), ]</td>
</tr>
<tr class="odd">
<td align="left"># ————————- # Step 4: build networks # ————————- if
(type == “first”) { for (j in 1:nwaves) { df_works_w &lt;-
df_works[df_works<span class="math inline">\(works_year &gt;=
waves[[j]][1] &amp;
df_works\)</span>works_year &lt;= waves[[j]][2], ] for (i in
1:nrow(df_works_w)) { ego &lt;- df_works_w<span
class="math inline">\(works_author[i][[1]]\)</span>au_id[1] alters &lt;-
df_works_w<span
class="math inline">\(works_author[i][[1]]\)</span>au_id[-1] if (sum(ids
%in% ego) &gt; 0 &amp; sum(ids %in% alters) &gt; 0) { nets[j, which(ids
%in% ego), which(ids %in% alters)] &lt;- 1 } } } }</td>
</tr>
<tr class="even">
<td align="left">if (type == “last”) { for (j in 1:nwaves) { df_works_w
&lt;- df_works[df_works<span class="math inline">\(works_year &gt;=
waves[[j]][1] &amp;
df_works\)</span>works_year &lt;= waves[[j]][2], ] for (i in
1:nrow(df_works_w)) { ego &lt;- rev(df_works_w<span
class="math inline">\(works_author[i][[1]]\)</span>au_id)[1] alters
&lt;- rev(df_works_w<span
class="math inline">\(works_author[i][[1]]\)</span>au_id)[-1] if
(sum(ids %in% ego) &gt; 0 &amp; sum(ids %in% alters) &gt; 0) { nets[j,
which(ids %in% ego), which(ids %in% alters)] &lt;- 1 } } } }</td>
</tr>
<tr class="odd">
<td align="left">if (type == “all”) { for (j in 1:nwaves) { df_works_w
&lt;- df_works[df_works<span class="math inline">\(works_year &gt;=
waves[[j]][1] &amp;
df_works\)</span>works_year &lt;= waves[[j]][2], ] for (i in
1:nrow(df_works_w)) { egos &lt;- df_works_w<span
class="math inline">\(works_author[i][[1]]\)</span>au_id if (sum(ids
%in% egos) &gt; 0) { nets[j, which(ids %in% egos), which(ids %in% egos)]
&lt;- 1 } } } }</td>
</tr>
<tr class="even">
<td align="left"># ————————- # Step 5: output # ————————- output &lt;-
list() output<span class="math inline">\(data &lt;- scholars_sel
output\)</span>nets &lt;- nets output$demographics &lt;-
demographics_all # includes gender if passed in</td>
</tr>
<tr class="odd">
<td align="left">return(output) } ``` ### output</td>
</tr>
<tr class="even">
<td align="left">``` r result_gender2 &lt;- fcolnet_gender( data =
scholars, demographics = df_scholars_gender, waves = list(c(2015, 2018),
c(2019,2023)), type= “first” )</td>
</tr>
<tr class="odd">
<td align="left"># View gender info head(result_gender2$demographics[,
c(“au_id”, “firstname”, “gender”)]) ```</td>
</tr>
<tr class="even">
<td
align="left"><code>## # A tibble: 6 × 3 ##   au_id                            firstname gender ##   &lt;chr&gt;                            &lt;chr&gt;     &lt;chr&gt; ## 1 https://openalex.org/A5076379849 Ece       female ## 2 https://openalex.org/A5043161143 Marcel    male ## 3 https://openalex.org/A5065278343 Weverthon &lt;NA&gt; ## 4 https://openalex.org/A5087995858 Vardan    male ## 5 https://openalex.org/A5038890249 Anne      female ## 6 https://openalex.org/A5060904065 Vincent   male</code></td>
</tr>
</tbody>
</table>
</div>
<div id="first-analyses" class="section level2" number="2">
<h2><span class="header-section-number">2</span> First analyses</h2>
<p><br></p>
<div id="check-waves" class="section level3" number="2.1">
<h3><span class="header-section-number">2.1</span> Check waves</h3>
<pre class="r"><code>wave1 &lt;- result_gender2$nets[1,,]
wave2 &lt;- result_gender2$nets[2,,]

# filter out the waves of the object: we need to check our input
dim(wave1)</code></pre>
<pre><code>## [1] 675 675</code></pre>
<pre class="r"><code>dim(wave2)</code></pre>
<pre><code>## [1] 675 675</code></pre>
<pre class="r"><code># you need to have 0 missing values:
sum(is.na(wave1))</code></pre>
<pre><code>## [1] 0</code></pre>
<pre class="r"><code>sum(is.na(wave2))</code></pre>
<pre><code>## [1] 0</code></pre>
<pre class="r"><code>#check the diagonal: all places should be 0
sum(diag(wave1)==0)</code></pre>
<pre><code>## [1] 671</code></pre>
<pre class="r"><code>sum(diag(wave2)==0)</code></pre>
<pre><code>## [1] 672</code></pre>
<pre class="r"><code># a few people did work with themselves:
diag(wave1) &lt;- 0
diag(wave2) &lt;- 0

# everything should be 1 or 0:
sum(wave1&gt;1)</code></pre>
<pre><code>## [1] 0</code></pre>
<pre class="r"><code>sum(wave2&gt;1)</code></pre>
<pre><code>## [1] 0</code></pre>
<pre class="r"><code># check if it&#39;s not empty: there are people with 1&#39;s
sum(wave1&gt;0)</code></pre>
<pre><code>## [1] 336</code></pre>
<pre class="r"><code>sum(wave2&gt;0)</code></pre>
<pre><code>## [1] 573</code></pre>
<pre class="r"><code>net_gender &lt;- array(data = c(wave1, wave2), dim = c(dim(wave1), 2))
# net_gender

# dependent
net2 &lt;- sienaDependent(net_gender)

# independent variables
gender &lt;- result_gender2$demographics$gender

gender &lt;- ifelse(gender==&quot;female&quot;,1,0)
gender &lt;- coCovar(gender)

#gender

# Create siena data object
mydata3 &lt;- sienaDataCreate(net2, gender)
mydata3</code></pre>
<pre><code>## Dependent variables:  net2 
## Number of observations: 2 
## 
## Nodeset                  Actors 
## Number of nodes             675 
## 
## Dependent variable net2          
## Type               oneMode       
## Observations       2             
## Nodeset            Actors        
## Densities          0.00074 0.0013
## 
## Constant covariates:  gender</code></pre>
<pre class="r"><code>myeff &lt;-getEffects(mydata3)

ifelse(!dir.exists(&quot;results&quot;), dir.create(&quot;results&quot;), FALSE)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>print01Report(mydata3, modelname = &quot;./results/soc_init2&quot;)</code></pre>
</div>
<div id="include-effects" class="section level3" number="2.2">
<h3><span class="header-section-number">2.2</span> Include effects</h3>
<pre class="r"><code>myeff &lt;- includeEffects(myeff, egoX, interaction1 = &quot;gender&quot;, type = &quot;eval&quot;, include = T)   

# can allso add the altX to the equation
myeff &lt;- setEffect(myeff, altX, interaction1 = &quot;gender&quot;, include = T)  

# can also add egoXaltX
myeff &lt;- setEffect(myeff, egoXaltX, interaction1 = &quot;gender&quot;, include = T)

myAlgorithm &lt;- sienaAlgorithmCreate(projname = &quot;soc_init&quot;)
ansM1 &lt;- siena07(myAlgorithm, data = mydata3, effects = myeff, returnDeps = TRUE)
# if necessary estimate again!  ansM1 &lt;- siena07(myAlgorithm, data = mydata, effects = myeff,
# prevAns = ansM1, returnDeps=TRUE)
ansM1</code></pre>
<p><br> This means that:</p>
<p>Outdegree: Significant and negative (b = -4.1697, SE = 0.0827): there
is an overall tendency not to form ties (most people collaborate with
few others)</p>
<p>Reciprocity: Significant and positive (b = 3.7150, SE = 0.1708):
mutual collaborations are more likely: if A co-authors with B, B is more
likely to co-author with A.</p>
<p>Gender ego: Significant and positive (b = 0.4094, SE = 0.1549): Being
a woman increases the likelihood of initiating co-authorships.</p>
<p>Gender alter: Significant and negative (b = -0.2908, SE = 0.0826):
Being a woman decreases the likelihood of being chosen as a
co-author.</p>
<p>Gender ego × gender alter: Significant and positive (b = 0.5069, SE =
0.1626) : Suggests same-gender collaborations are more likely than
cross-gender ones.</p>
<hr />
</div>
</div>
<div id="rsienna-chapters" class="section level2" number="3">
<h2><span class="header-section-number">3</span> RSienna chapters</h2>
<p><br></p>
<div id="chapter-2" class="section level3" number="3.1">
<h3><span class="header-section-number">3.1</span> Chapter 2</h3>
<p>The defining characteristic of Stochastic Actor-Oriented Models is
their ‘actor-oriented’ nature which means that they model change from
the perspective of the actors (nodes).</p>
<p>For network evolution, three conceptual functions may be used:
evaluation, creation, and endowment. These differ in whether one models
all tie presence (evaluation), just tie formation (creation), or tie
maintenance (endowment).</p>
<p>Effects: These are the modeled influences (explanatory factors) on
change.</p>
<ul>
<li><p>Structural effects (endogenous) e.g. reciprocity,
transitivity</p></li>
<li><p>Covariate effects (exogenous) e.g. similarity, attribute of
sender/receiver</p></li>
<li><p>Interaction effects (combinations) e.g. interaction of structure
and covariate</p></li>
</ul>
<p>Estimation procedure:</p>
<p>RSiena uses the function siena07 to estimate parameters.The goal is
that the model-implied (expected) network/behavioral statistics match
observed statistics.</p>
<p>The estimation proceeds in phases:</p>
<ul>
<li><p>Estimate sensitivity of statistics to parameters</p></li>
<li><p>Iterative updates: simulate networks, compute deviations, adjust
parameters</p></li>
<li><p>Check convergence: whether simulated statistics are close enough
to observed targets</p></li>
</ul>
<p>If convergence criteria are not met, estimation may be repeated or
refined.</p>
<p><br> ### Chapter 5</p>
<p>In many applications, it’s best to start with a simple baseline model
(e.g. including only core structural effects like out-degree and
reciprocity).</p>
<p>From there, add or remove effects (in small sets, e.g. 1–3 at a
time), assessing convergence, interpretability, and fit at each
stage.</p>
<p>It is wise to always retain certain “anchor” effects (e.g. out-degree
or rate parameters) even if they are not statistically significant,
because they stabilize the model structure.</p>
<hr />
</div>
</div>
<div id="second-analyses" class="section level2" number="4">
<h2><span class="header-section-number">4</span> Second analyses</h2>
<div id="transtrip" class="section level3" number="4.1">
<h3><span class="header-section-number">4.1</span> transTrip</h3>
<p>There are many Structural effects you can include. I tried around
with triangulation, but I did not think it really fit my gender
research. It could be interesting: if you have A -&gt; B -&gt; C, would
the gender of B impact whether A -&gt; C would collaborate.</p>
<pre class="r"><code>myeff &lt;- includeEffects(myeff, egoX, interaction1 = &quot;gender&quot;, type = &quot;eval&quot;, include = T) 
myeff &lt;- setEffect(myeff, altX, interaction1 = &quot;gender&quot;, include = T) 
myeff &lt;- setEffect(myeff, egoXaltX, interaction1 = &quot;gender&quot;, include = T)

myeff &lt;- includeEffects(myeff, transTrip, include = T)
myeff &lt;- includeEffects(myeff, transTripX, interaction1 = &quot;gender&quot;, type = &quot;eval&quot;, include = T)

myAlgorithm &lt;- sienaAlgorithmCreate(projname = &quot;soc_init&quot;)
ansM2 &lt;- siena07(myAlgorithm, data = mydata3, effects = myeff, returnDeps = TRUE)
# if necessary estimate again!  ansM1 &lt;- siena07(myAlgorithm, data = mydata, effects = myeff,
# prevAns = ansM1, returnDeps=TRUE)
ansM2</code></pre>
<p>The network shows a significant tendency toward transitive closure (b
= 1.9166, SE = 0.1786), meaning that “friends of friends” are more
likely to become connected. The effect of transitive triplets moderated
by the intermediate person’s gender is not significant (b = 0.1580, SE =
0.5294), suggesting that the gender of the intermediate has no influence
on whether triads close. If you have A -&gt; B -&gt; C, the gender of B
does not impact whether A -&gt; C would collaborate.</p>
<p><br></p>
<p>Formula: <img src="images/Triad.png" /> <br> For all alters j, if ego
i is tied to an intermediary h who is a woman (male = 0, female = 1) and
intermediary h has a connection to alter j, and alter j has a connection
to ego i, then that configuration adds 1 to i’s transTripX
statistic.</p>
<p><br></p>
</div>
<div id="inpop" class="section level3" number="4.2">
<h3><span class="header-section-number">4.2</span> inPop</h3>
<pre class="r"><code># first put the triadic effects on: do not include
myeff &lt;- includeEffects(myeff, transTrip, include = F)
myeff &lt;- includeEffects(myeff, transTripX, interaction1 = &quot;gender&quot;, type = &quot;eval&quot;, include = F)

# Get ego, alt and egoalt effects
myeff &lt;- includeEffects(myeff, egoX, interaction1 = &quot;gender&quot;, type = &quot;eval&quot;, include = T) 
myeff &lt;- setEffect(myeff, altX, interaction1 = &quot;gender&quot;, include = T) 
myeff &lt;- setEffect(myeff, egoXaltX, interaction1 = &quot;gender&quot;, include = T)

myeff &lt;- includeEffects(myeff, inPop, include = T)

myeff &lt;- includeInteraction(myeff, egoX, inPop, interaction1 = c(&quot;gender&quot;, &quot;&quot;), type = &quot;eval&quot;, include = T)

myAlgorithm &lt;- sienaAlgorithmCreate(projname = &quot;soc_init&quot;)
ansM3 &lt;- siena07(myAlgorithm, data = mydata3, effects = myeff, returnDeps = TRUE)
# if necessary estimate again!  ansM1 &lt;- siena07(myAlgorithm, data = mydata, effects = myeff,
# prevAns = ansM1, returnDeps=TRUE)
ansM3</code></pre>
<p><br></p>
<p>I am not sure whether I am interpreting this correctly but:</p>
<p>The indegree-popularity effect was significant and positive (b =
0.19, SE = 0.03) uggesting that actors who received more nominations
were more likely to attract additional ones.</p>
<p>Women in the network initially received fewer ties than men, but
after including the indegree–popularity effect, the main gender effects
were no longer significant (gender ego: b = 0.33, SE = 0.22; gender
alter: b = –0.14, SE = 0.13). This suggests that the observed gender
differences were largely explained by popularity rather than gender
itself. The interaction between gender ego and indegree–popularity (b =
0.03, SE = 0.06) was also non-significant, indicating that popularity
influences tie formation similarly for men and women. Overall, gender
differences in tie initiation appear to stem from structural network
dynamics—such as a preference for connecting to already popular alters,
among whom men are likely overrepresented—rather than from direct
gender-based effects.</p>
<p><br> The formula: <img src="images/inPop.png" /> For all alter’s (j):
if an ego (i) has a tie to an alter (j) sum for the alter (j) the number
of its alters (h) which are not ego (i), and then you do plus one
because you also want to count the one connection to ego (i).</p>
</div>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiSm91cm5hbCAxIgojYmlibGlvZ3JhcGh5OiByZWZlcmVuY2VzLmJpYgphdXRob3I6ICJNeWzDqG5lIEh1c3NvbiIKLS0tCgpgYGB7ciwgZWNobz1UUlVFLCByZXN1bHRzPSdoaWRlJywgbWVzc2FnZT1GQUxTRSwgd2FybmluZz1GQUxTRX0KbGlicmFyeShrbml0cikKbGlicmFyeSh0aWR5dmVyc2UpCmxpYnJhcnkoc2Nob2xhcikKbGlicmFyeShvcGVuYWxleFIpCmxpYnJhcnkocnZlc3QpCmxpYnJhcnkoanNvbmxpdGUpCmxpYnJhcnkoaHR0cikKbGlicmFyeShydmVzdCkKbGlicmFyeShyZXNoYXBlMikKbGlicmFyeSh4bWwyKQpsaWJyYXJ5KG9wZW54bHN4KQpsaWJyYXJ5KHBvbGl0ZSkKbGlicmFyeShpZ3JhcGgpCmxpYnJhcnkoc25hKQpsaWJyYXJ5KGdlbmRlcml6ZVIpCmxpYnJhcnkoUlNlbGVuaXVtKQpsaWJyYXJ5KG5ldHN0YXQpCmxpYnJhcnkocGluZ3IpCmxpYnJhcnkoUlNpZW5hKQpsaWJyYXJ5KGRldnRvb2xzKQpsaWJyYXJ5KFJzaWVuYVR3b1N0ZXApCgoKIyBsb2FkIHRoZSBmdW5jdGlvbnMgeW91IG5lZWQgZnJvbSB0aGUgcGFja2FnZXMKZnBhY2thZ2UuY2hlY2sgPC0gZnVuY3Rpb24ocGFja2FnZXMpIHsKICBsYXBwbHkocGFja2FnZXMsIEZVTiA9IGZ1bmN0aW9uKHgpIHsKICAgIGlmICghcmVxdWlyZSh4LCBjaGFyYWN0ZXIub25seSA9IFRSVUUpKSB7CiAgICAgIGluc3RhbGwucGFja2FnZXMoeCwgZGVwZW5kZW5jaWVzID0gVFJVRSkKICAgICAgbGlicmFyeSh4LCBjaGFyYWN0ZXIub25seSA9IFRSVUUpCiAgICB9CiAgfSkKfQoKZnNhdmUgPC0gZnVuY3Rpb24oeCwgZmlsZSA9IE5VTEwsIGxvY2F0aW9uID0gIi4vZGF0YS9wcm9jZXNzZWQvIikgewogIGlmZWxzZSghZGlyLmV4aXN0cygiZGF0YSIpLCBkaXIuY3JlYXRlKCJkYXRhIiksIEZBTFNFKQogIGlmZWxzZSghZGlyLmV4aXN0cygiZGF0YS9wcm9jZXNzZWQiKSwgZGlyLmNyZWF0ZSgiZGF0YS9wcm9jZXNzZWQiKSwgRkFMU0UpCiAgCiAgaWYgKGlzLm51bGwoZmlsZSkpIHsKICAgIGZpbGUgPC0gZGVwYXJzZShzdWJzdGl0dXRlKHgpKQogIH0KICAKICBkYXRlbmFtZSA8LSBzdWJzdHIoZ3N1YigiWzotXSIsICIiLCBTeXMudGltZSgpKSwgMSwgOCkKICB0b3RhbG5hbWUgPC0gcGFzdGUobG9jYXRpb24sIGRhdGVuYW1lLCBmaWxlLCAiLnJkYSIsIHNlcCA9ICIiKQogIHNhdmUoeCwgZmlsZSA9IHRvdGFsbmFtZSkgICMgbmVlZCB0byBmaXggaWYgZmlsZSBpcyByZWxvYWRlZCBhcyBpbnB1dCBuYW1lLCBub3QgYXMgeC4KfQoKZmxvYWQgPC0gZnVuY3Rpb24oZmlsZW5hbWUpIHsKICBsb2FkKGZpbGVuYW1lKQogIGdldChscygpW2xzKCkgIT0gImZpbGVuYW1lIl0pCn0KCmZzaG93ZGYgPC0gZnVuY3Rpb24oeCwgLi4uKSB7CiAga25pdHI6OmthYmxlKHgsIGRpZ2l0cyA9IDIsICJodG1sIiwgLi4uKSAlPiUKICAgIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpICU+JQogICAga2FibGVFeHRyYTo6c2Nyb2xsX2JveCh3aWR0aCA9ICIxMDAlIiwgaGVpZ2h0ID0gIjMwMHB4IikKfQpgYGAKCmBgYHtyIGtsaXBweSwgZWNobz1GQUxTRSwgaW5jbHVkZT1UUlVFfQprbGlwcHk6OmtsaXBweShwb3NpdGlvbiA9IGMoJ3RvcCcsICdyaWdodCcpKQoja2xpcHB5OjprbGlwcHkoY29sb3IgPSAnZGFya3JlZCcpCiNrbGlwcHk6OmtsaXBweSh0b29sdGlwX21lc3NhZ2UgPSAnQ2xpY2sgdG8gY29weScsIHRvb2x0aXBfc3VjY2VzcyA9ICdEb25lJykKYGBgCgpMYXN0IGNvbXBpbGVkIG9uIGByIGZvcm1hdChTeXMudGltZSgpLCAnJUIsICVZJylgCjxicj4KCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyMgQ3JlYXRlIERhdGFzZXQKPGJyPgoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiMjIyBHZW5kZXJpemUgZnVuY3Rpb24KYGBge3J9CgpteV9nZW5kZXJpemVyIDwtIGZ1bmN0aW9uKG5hbWUpIHsKICBuYW1lIDwtIGdzdWIoIl4vK3wvKyQiLCAiIiwgbmFtZSkKICAKICAjIEJ1aWxkIFVSTAogIGJhc2VfdXJsIDwtICJodHRwczovL252Yi5tZWVydGVucy5rbmF3Lm5sL25hYW0vaXMiCiAgbmFtZV91cmwgPC0gcGFzdGUwKGJhc2VfdXJsLCAiLyIsIG5hbWUpCiAgCiAgIyBUcnkgcmVhZGluZyB0YWJsZQogIHRhYmxlIDwtIHRyeUNhdGNoKAogICAgcmVhZF9odG1sKG5hbWVfdXJsKSB8PgogICAgICBodG1sX2VsZW1lbnQoInRhYmxlIikgfD4KICAgICAgaHRtbF90YWJsZSgpLAogICAgZXJyb3IgPSBmdW5jdGlvbihlKSBOVUxMCiAgKQogIAogIGlmIChpcy5udWxsKHRhYmxlKSkgcmV0dXJuKE5BKSAgIyByZXR1cm4gTkEgaWYgbm8gdGFibGUgZm91bmQKICAKICAjIFJlcGxhY2UgIi0tIiB3aXRoICIwIgogIHRhYmxlW3RhYmxlID09ICItLSJdIDwtICIwIgogIAogICMgQ29udmVydCB0byBudW1lcmljCiAgdmFsX21hbGUgICA8LSBzdXBwcmVzc1dhcm5pbmdzKGFzLm51bWVyaWModGFibGVbMiwgM10pKQogIHZhbF9mZW1hbGUgPC0gc3VwcHJlc3NXYXJuaW5ncyhhcy5udW1lcmljKHRhYmxlWzYsIDNdKSkKICAKICAjIERlY2lkZSBnZW5kZXIKICBpZiAoaXMubmEodmFsX21hbGUpICYgaXMubmEodmFsX2ZlbWFsZSkpIHsKICAgIGdlbmRlciA8LSBOQQogIH0gZWxzZSBpZiAodmFsX21hbGUgPiB2YWxfZmVtYWxlKSB7CiAgICBnZW5kZXIgPC0gIm1hbGUiCiAgfSBlbHNlIGlmICh2YWxfZmVtYWxlID4gdmFsX21hbGUpIHsKICAgIGdlbmRlciA8LSAiZmVtYWxlIgogIH0gZWxzZSB7CiAgICBnZW5kZXIgPC0gTkEKICB9CiAgCiAgcmV0dXJuKGdlbmRlcikKfQpgYGAKPGJyPgojIyMgTG9hZCB0aGUgZGF0YQpgYGB7cn0KIyBsb2FkIGluIHRoZSBkYXRhCnNjaG9sYXJzIDwtIGZsb2FkKCIuL2RhdGEvcHJvY2Vzc2VkL3NjaG9sYXJzXzIwMjQwOTI0LnJkYSIpCgojIHNlbGVjdCBzY2hvbGFycwojIChzb2Npb2xvZ3ksIFJVKQpkZW1vZ3JhcGhpY3MgPC0gZG8uY2FsbChyYmluZC5kYXRhLmZyYW1lLCBzY2hvbGFycyRkZW1vZ3JhcGhpY3MpCmRlbW9ncmFwaGljcyA8LSBkZW1vZ3JhcGhpY3MgJT4lCiAgICBtdXRhdGUoVW5pdmVyc2l0ZWl0MS4yMiA9IHJlcGxhY2UoVW5pdmVyc2l0ZWl0MS4yMiwgaXMubmEoVW5pdmVyc2l0ZWl0MS4yMiksICIiKSwgVW5pdmVyc2l0ZWl0Mi4yMiA9IHJlcGxhY2UoVW5pdmVyc2l0ZWl0Mi4yMiwKICAgICAgICBpcy5uYShVbml2ZXJzaXRlaXQyLjIyKSwgIiIpLCBVbml2ZXJzaXRlaXQxLjI0ID0gcmVwbGFjZShVbml2ZXJzaXRlaXQxLjI0LCBpcy5uYShVbml2ZXJzaXRlaXQxLjI0KSwKICAgICAgICAiIiksIFVuaXZlcnNpdGVpdDIuMjQgPSByZXBsYWNlKFVuaXZlcnNpdGVpdDIuMjQsIGlzLm5hKFVuaXZlcnNpdGVpdDIuMjQpLCAiIiksIGRpc2NpcGxpbmUuMjIgPSByZXBsYWNlKGRpc2NpcGxpbmUuMjIsCiAgICAgICAgaXMubmEoZGlzY2lwbGluZS4yMiksICIiKSwgZGlzY2lwbGluZS4yNCA9IHJlcGxhY2UoZGlzY2lwbGluZS4yNCwgaXMubmEoZGlzY2lwbGluZS4yNCksICIiKSkKCnNhbXBsZSA8LSB3aGljaCgoZGVtb2dyYXBoaWNzJFVuaXZlcnNpdGVpdDEuMjIgPT0gIlJVIiB8IGRlbW9ncmFwaGljcyRVbml2ZXJzaXRlaXQyLjIyID09ICJSVSIgfCBkZW1vZ3JhcGhpY3MkVW5pdmVyc2l0ZWl0MS4yNCA9PQogICAgIlJVIiB8IGRlbW9ncmFwaGljcyRVbml2ZXJzaXRlaXQyLjI0ID09ICJSVSIpICYgKGRlbW9ncmFwaGljcyRkaXNjaXBsaW5lLjIyID09ICJzb2Npb2xvZ3kiIHwgZGVtb2dyYXBoaWNzJGRpc2NpcGxpbmUuMjQgPT0KICAgICJzb2Npb2xvZ3kiKSkKCmRlbW9ncmFwaGljc19zb2MgPC0gZGVtb2dyYXBoaWNzW3NhbXBsZSwgXQpzY2hvbGFyc19zZWwgPC0gbGFwcGx5KHNjaG9sYXJzLCAiWyIsIHNhbXBsZSkKCiMgY29uc3RydWN0IHRoZSBlbXB0eSBhZGphY2VuY3kgbWF0cml4CmlkcyA8LSBkZW1vZ3JhcGhpY3Nfc29jJGF1X2lkCndhdmUyIDwtIHdhdmUxIDwtIG1hdHJpeCgwLCBucm93ID0gbGVuZ3RoKGlkcyksIG5jb2wgPSBsZW5ndGgoaWRzKSwgZGltbmFtZXMgPSBsaXN0KGlkcywgaWRzKSkKCiMgZmlsdGVyIHdvcmtzCndvcmtzIDwtIHNjaG9sYXJzX3NlbCR3b3JrCgp3b3Jrc19pZCA8LSB1bmxpc3QobGFwcGx5KHdvcmtzLCBmdW5jdGlvbihsKSBsJGlkKSkKd29ya3NfYXV0aG9yIDwtIHVubGlzdChsYXBwbHkod29ya3MsIGZ1bmN0aW9uKGwpIGwkYXV0aG9yKSwgcmVjdXJzaXZlID0gRkFMU0UpCndvcmtzX3llYXIgPC0gdW5saXN0KGxhcHBseSh3b3JrcywgZnVuY3Rpb24obCkgbCRwdWJsaWNhdGlvbl95ZWFyKSwgcmVjdXJzaXZlID0gRkFMU0UpCgpkZl93b3JrcyA8LSB0aWJibGUod29ya3NfaWQsIHdvcmtzX2F1dGhvciwgd29ya3NfeWVhcikKCmR1cHMgPC0gd2hpY2goZHVwbGljYXRlZCh3b3Jrc19pZCkpCgpkZl93b3JrcyA8LSBkZl93b3Jrc1stZHVwcywgXQpkZl93b3Jrc193MiA8LSBkZl93b3Jrc1tkZl93b3JrcyR3b3Jrc195ZWFyID4gMjAxOSwgXQoKIyB1bmRpcmVjdGVkCiMgdW5kaXJlY3RlZApmb3IgKGkgaW4gMTpucm93KGRmX3dvcmtzX3cyKSkgewogICAgZWdvcyA8LSBkZl93b3Jrc193MiR3b3Jrc19hdXRob3JbaV1bWzFdXSRhdV9pZAoKICAgIGlmIChzdW0oaWRzICVpbiUgZWdvcykgPiAwKSB7CiAgICAgICAgd2F2ZTJbd2hpY2goaWRzICVpbiUgZWdvcyksIHdoaWNoKGlkcyAlaW4lIGVnb3MpXSA8LSAxCiAgICB9Cn0KCmZjb2xuZXQgPC0gZnVuY3Rpb24oZGF0YSA9IHNjaG9sYXJzLCB1bml2ZXJzaXR5ID0gIlJVIiwgZGlzY2lwbGluZSA9ICJzb2Npb2xvZ3kiLCB3YXZlcyA9IGxpc3QoYygyMDE1LAogICAgMjAxOCksIGMoMjAxOSwgMjAyMykpLCB0eXBlID0gYygiZmlyc3QiKSkgewoKICAgICMgc3RlcCAxCiAgICBkZW1vZ3JhcGhpY3MgPC0gZG8uY2FsbChyYmluZC5kYXRhLmZyYW1lLCBkYXRhJGRlbW9ncmFwaGljcykKICAgIGRlbW9ncmFwaGljcyA8LSBkZW1vZ3JhcGhpY3MgJT4lCiAgICAgICAgbXV0YXRlKFVuaXZlcnNpdGVpdDEuMjIgPSByZXBsYWNlKFVuaXZlcnNpdGVpdDEuMjIsIGlzLm5hKFVuaXZlcnNpdGVpdDEuMjIpLCAiIiksIFVuaXZlcnNpdGVpdDIuMjIgPSByZXBsYWNlKFVuaXZlcnNpdGVpdDIuMjIsCiAgICAgICAgICAgIGlzLm5hKFVuaXZlcnNpdGVpdDIuMjIpLCAiIiksIFVuaXZlcnNpdGVpdDEuMjQgPSByZXBsYWNlKFVuaXZlcnNpdGVpdDEuMjQsIGlzLm5hKFVuaXZlcnNpdGVpdDEuMjQpLAogICAgICAgICAgICAiIiksIFVuaXZlcnNpdGVpdDIuMjQgPSByZXBsYWNlKFVuaXZlcnNpdGVpdDIuMjQsIGlzLm5hKFVuaXZlcnNpdGVpdDIuMjQpLCAiIiksIGRpc2NpcGxpbmUuMjIgPSByZXBsYWNlKGRpc2NpcGxpbmUuMjIsCiAgICAgICAgICAgIGlzLm5hKGRpc2NpcGxpbmUuMjIpLCAiIiksIGRpc2NpcGxpbmUuMjQgPSByZXBsYWNlKGRpc2NpcGxpbmUuMjQsIGlzLm5hKGRpc2NpcGxpbmUuMjQpLCAiIikpCgogICAgc2FtcGxlIDwtIHdoaWNoKChkZW1vZ3JhcGhpY3MkVW5pdmVyc2l0ZWl0MS4yMiAlaW4lIHVuaXZlcnNpdHkgfCBkZW1vZ3JhcGhpY3MkVW5pdmVyc2l0ZWl0Mi4yMiAlaW4lCiAgICAgICAgdW5pdmVyc2l0eSB8IGRlbW9ncmFwaGljcyRVbml2ZXJzaXRlaXQxLjI0ICVpbiUgdW5pdmVyc2l0eSB8IGRlbW9ncmFwaGljcyRVbml2ZXJzaXRlaXQyLjI0ICVpbiUKICAgICAgICB1bml2ZXJzaXR5KSAmIChkZW1vZ3JhcGhpY3MkZGlzY2lwbGluZS4yMiAlaW4lIGRpc2NpcGxpbmUgfCBkZW1vZ3JhcGhpY3MkZGlzY2lwbGluZS4yNCAlaW4lIGRpc2NpcGxpbmUpKQoKICAgIGRlbW9ncmFwaGljc19zb2MgPC0gZGVtb2dyYXBoaWNzW3NhbXBsZSwgXQogICAgc2Nob2xhcnNfc2VsIDwtIGxhcHBseShzY2hvbGFycywgIlsiLCBzYW1wbGUpCgogICAgIyBzdGVwIDIKICAgIGlkcyA8LSBkZW1vZ3JhcGhpY3Nfc29jJGF1X2lkCiAgICBud2F2ZXMgPC0gbGVuZ3RoKHdhdmVzKQogICAgbmV0cyA8LSBhcnJheSgwLCBkaW0gPSBjKG53YXZlcywgbGVuZ3RoKGlkcyksIGxlbmd0aChpZHMpKSwgZGltbmFtZXMgPSBsaXN0KHdhdmUgPSAxOm53YXZlcywgaWRzLAogICAgICAgIGlkcykpCiAgICBkaW1uYW1lcyhuZXRzKQoKICAgICMgc3RlcCAzCiAgICBkZl93b3JrcyA8LSB0aWJibGUod29ya3NfaWQgPSB1bmxpc3QobGFwcGx5KHNjaG9sYXJzX3NlbCR3b3JrLCBmdW5jdGlvbihsKSBsJGlkKSksIHdvcmtzX2F1dGhvciA9IHVubGlzdChsYXBwbHkoc2Nob2xhcnNfc2VsJHdvcmssCiAgICAgICAgZnVuY3Rpb24obCkgbCRhdXRob3IpLCByZWN1cnNpdmUgPSBGQUxTRSksIHdvcmtzX3llYXIgPSB1bmxpc3QobGFwcGx5KHNjaG9sYXJzX3NlbCR3b3JrLCBmdW5jdGlvbihsKSBsJHB1YmxpY2F0aW9uX3llYXIpLAogICAgICAgIHJlY3Vyc2l2ZSA9IEZBTFNFKSkKCiAgICBkZl93b3JrcyA8LSBkZl93b3Jrc1shZHVwbGljYXRlZChkZl93b3JrcyksIF0KCiAgICAjIHN0ZXAgNAogICAgaWYgKHR5cGUgPT0gImZpcnN0IikgewogICAgICAgIGZvciAoaiBpbiAxOm53YXZlcykgewogICAgICAgICAgICBkZl93b3Jrc193IDwtIGRmX3dvcmtzW2RmX3dvcmtzJHdvcmtzX3llYXIgPj0gd2F2ZXNbW2pdXVsxXSAmIGRmX3dvcmtzJHdvcmtzX3llYXIgPD0gd2F2ZXNbW2pdXVsyXSwKICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgZm9yIChpIGluIDE6bnJvdyhkZl93b3Jrc193KSkgewogICAgICAgICAgICAgICAgZWdvIDwtIGRmX3dvcmtzX3ckd29ya3NfYXV0aG9yW2ldW1sxXV0kYXVfaWRbMV0KICAgICAgICAgICAgICAgIGFsdGVycyA8LSBkZl93b3Jrc193JHdvcmtzX2F1dGhvcltpXVtbMV1dJGF1X2lkWy0xXQogICAgICAgICAgICAgICAgaWYgKHN1bShpZHMgJWluJSBlZ28pID4gMCAmIHN1bShpZHMgJWluJSBhbHRlcnMpID4gMCkgewogICAgICAgICAgICAgICAgICBuZXRzW2osIHdoaWNoKGlkcyAlaW4lIGVnbyksIHdoaWNoKGlkcyAlaW4lIGFsdGVycyldIDwtIDEKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0KCiAgICBpZiAodHlwZSA9PSAibGFzdCIpIHsKICAgICAgICBmb3IgKGogaW4gMTpud2F2ZXMpIHsKICAgICAgICAgICAgZGZfd29ya3NfdyA8LSBkZl93b3Jrc1tkZl93b3JrcyR3b3Jrc195ZWFyID49IHdhdmVzW1tqXV1bMV0gJiBkZl93b3JrcyR3b3Jrc195ZWFyIDw9IHdhdmVzW1tqXV1bMl0sCiAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgIGZvciAoaSBpbiAxOm5yb3coZGZfd29ya3NfdykpIHsKICAgICAgICAgICAgICAgIGVnbyA8LSByZXYoZGZfd29ya3NfdyR3b3Jrc19hdXRob3JbaV1bWzFdXSRhdV9pZClbMV0KICAgICAgICAgICAgICAgIGFsdGVycyA8LSByZXYoZGZfd29ya3NfdyR3b3Jrc19hdXRob3JbaV1bWzFdXSRhdV9pZClbLTFdCiAgICAgICAgICAgICAgICBpZiAoc3VtKGlkcyAlaW4lIGVnbykgPiAwICYgc3VtKGlkcyAlaW4lIGFsdGVycykgPiAwKSB7CiAgICAgICAgICAgICAgICAgIG5ldHNbaiwgd2hpY2goaWRzICVpbiUgZWdvKSwgd2hpY2goaWRzICVpbiUgYWx0ZXJzKV0gPC0gMQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQoKICAgIGlmICh0eXBlID09ICJhbGwiKSB7CiAgICAgICAgZm9yIChqIGluIDE6bndhdmVzKSB7CiAgICAgICAgICAgIGRmX3dvcmtzX3cgPC0gZGZfd29ya3NbZGZfd29ya3Mkd29ya3NfeWVhciA+PSB3YXZlc1tbal1dWzFdICYgZGZfd29ya3Mkd29ya3NfeWVhciA8PSB3YXZlc1tbal1dWzJdLAogICAgICAgICAgICAgICAgXQogICAgICAgICAgICBmb3IgKGkgaW4gMTpucm93KGRmX3dvcmtzX3cpKSB7CiAgICAgICAgICAgICAgICBlZ29zIDwtIGRmX3dvcmtzX3ckd29ya3NfYXV0aG9yW2ldW1sxXV0kYXVfaWQKICAgICAgICAgICAgICAgIGlmIChzdW0oaWRzICVpbiUgZWdvcykgPiAwKSB7CiAgICAgICAgICAgICAgICAgIG5ldHNbaiwgd2hpY2goaWRzICVpbiUgZWdvcyksIHdoaWNoKGlkcyAlaW4lIGVnb3MpXSA8LSAxCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9CiAgICBvdXRwdXQgPC0gbGlzdCgpCiAgICBvdXRwdXQkZGF0YSA8LSBzY2hvbGFyc19zZWwKICAgIG91dHB1dCRuZXRzIDwtIG5ldHMKICAgIHJldHVybihvdXRwdXQpCn0KCmRmX3NjaG9sYXJzIDwtIGRvLmNhbGwocmJpbmQsIHNjaG9sYXJzJGRlbW9ncmFwaGljcykKYGBgCjxicj4KIyMjIEF0dGFjaCBnZW5kZXIKYGBge3J9CmRmX3NjaG9sYXJzX2dlbmRlciA8LSBkZl9zY2hvbGFycyB8PgogIG11dGF0ZShmaXJzdG5hbWUgPSB3b3JkKE5hYW0sIDEpKSAgIyBleHRyYWN0IGZpcnN0IG5hbWVzCgpkZl9zY2hvbGFyc19nZW5kZXIkZ2VuZGVyIDwtIE5BX2NoYXJhY3Rlcl8gICMgaW5pdGlhbGl6ZSBnZW5kZXIgY29sdW1uCgpmb3IgKGkgaW4gc2VxX2xlbihucm93KGRmX3NjaG9sYXJzX2dlbmRlcikpKSB7CiAgbmFtZSA8LSBkZl9zY2hvbGFyc19nZW5kZXIkZmlyc3RuYW1lW2ldCiAgZ2VuZGVyIDwtIG15X2dlbmRlcml6ZXIobmFtZSkKICAKICBkZl9zY2hvbGFyc19nZW5kZXIkZ2VuZGVyW2ldIDwtIGdlbmRlcgogIFN5cy5zbGVlcCgwLjA2KSAgIyBwYXVzZSBiZXR3ZWVuIHJlcXVlc3RzCn0KYGBgCjxicj4KIyMjIEJpZyBkYXRhCmBgYHtyfQpmY29sbmV0X2dlbmRlciA8LSBmdW5jdGlvbihkYXRhID0gc2Nob2xhcnMsCiAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhdmVzID0gbGlzdChjKDIwMTUsIDIwMTgpLCBjKDIwMTksIDIwMjMpKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICJmaXJzdCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbW9ncmFwaGljcyA9IE5VTEwpIHsKICAKICAjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAjIFN0ZXAgMTogZGVtb2dyYXBoaWNzCiAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgaWYgKGlzLm51bGwoZGVtb2dyYXBoaWNzKSkgewogICAgZGVtb2dyYXBoaWNzIDwtIGRvLmNhbGwocmJpbmQuZGF0YS5mcmFtZSwgZGF0YSRkZW1vZ3JhcGhpY3MpCiAgfQogIAogIGRlbW9ncmFwaGljcyA8LSBkZW1vZ3JhcGhpY3MgJT4lCiAgICBtdXRhdGUoCiAgICAgIFVuaXZlcnNpdGVpdDEuMjIgPSByZXBsYWNlKFVuaXZlcnNpdGVpdDEuMjIsIGlzLm5hKFVuaXZlcnNpdGVpdDEuMjIpLCAiIiksCiAgICAgIFVuaXZlcnNpdGVpdDIuMjIgPSByZXBsYWNlKFVuaXZlcnNpdGVpdDIuMjIsIGlzLm5hKFVuaXZlcnNpdGVpdDIuMjIpLCAiIiksCiAgICAgIFVuaXZlcnNpdGVpdDEuMjQgPSByZXBsYWNlKFVuaXZlcnNpdGVpdDEuMjQsIGlzLm5hKFVuaXZlcnNpdGVpdDEuMjQpLCAiIiksCiAgICAgIFVuaXZlcnNpdGVpdDIuMjQgPSByZXBsYWNlKFVuaXZlcnNpdGVpdDIuMjQsIGlzLm5hKFVuaXZlcnNpdGVpdDIuMjQpLCAiIiksCiAgICAgIGRpc2NpcGxpbmUuMjIgICAgPSByZXBsYWNlKGRpc2NpcGxpbmUuMjIsICAgIGlzLm5hKGRpc2NpcGxpbmUuMjIpLCAgICAiIiksCiAgICAgIGRpc2NpcGxpbmUuMjQgICAgPSByZXBsYWNlKGRpc2NpcGxpbmUuMjQsICAgIGlzLm5hKGRpc2NpcGxpbmUuMjQpLCAgICAiIikKICAgICkKICAKICAjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAjIHNlbGVjdCBhbGwgc2Nob2xhcnMKICAjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICBzYW1wbGUgPC0gc2VxX2xlbihucm93KGRlbW9ncmFwaGljcykpCiAgCiAgZGVtb2dyYXBoaWNzX2FsbCA8LSBkZW1vZ3JhcGhpY3Nbc2FtcGxlLCBdCiAgc2Nob2xhcnNfc2VsIDwtIGxhcHBseShkYXRhLCAiWyIsIHNhbXBsZSkKICAKICAjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAjIFN0ZXAgMjogaW5pdGlhbGl6ZSBuZXR3b3JrIGFycmF5CiAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgaWRzIDwtIGRlbW9ncmFwaGljc19hbGwkYXVfaWQKICBud2F2ZXMgPC0gbGVuZ3RoKHdhdmVzKQogIG5ldHMgPC0gYXJyYXkoCiAgICAwLAogICAgZGltID0gYyhud2F2ZXMsIGxlbmd0aChpZHMpLCBsZW5ndGgoaWRzKSksCiAgICBkaW1uYW1lcyA9IGxpc3Qod2F2ZSA9IDE6bndhdmVzLCBpZHMsIGlkcykKICApCiAgCiAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgIyBTdGVwIDM6IHdvcmtzIGRhdGFmcmFtZQogICMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogIGRmX3dvcmtzIDwtIHRpYmJsZSgKICAgIHdvcmtzX2lkICAgICA9IHVubGlzdChsYXBwbHkoc2Nob2xhcnNfc2VsJHdvcmssIGZ1bmN0aW9uKGwpIGlmKCFpcy5udWxsKGwpKSBsJGlkIGVsc2UgTkEpKSwKICAgIHdvcmtzX2F1dGhvciA9IHVubGlzdChsYXBwbHkoc2Nob2xhcnNfc2VsJHdvcmssIGZ1bmN0aW9uKGwpIGlmKCFpcy5udWxsKGwpKSBsJGF1dGhvciBlbHNlIE5BKSwgcmVjdXJzaXZlID0gRkFMU0UpLAogICAgd29ya3NfeWVhciAgID0gdW5saXN0KGxhcHBseShzY2hvbGFyc19zZWwkd29yaywgZnVuY3Rpb24obCkgaWYoIWlzLm51bGwobCkpIGwkcHVibGljYXRpb25feWVhciBlbHNlIE5BKSwgcmVjdXJzaXZlID0gRkFMU0UpCiAgKSAlPiUgZmlsdGVyKCFpcy5uYSh3b3Jrc19pZCkpCiAgCiAgZGZfd29ya3MgPC0gZGZfd29ya3NbIWR1cGxpY2F0ZWQoZGZfd29ya3MpLCBdCiAgCiAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgIyBTdGVwIDQ6IGJ1aWxkIG5ldHdvcmtzCiAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgaWYgKHR5cGUgPT0gImZpcnN0IikgewogICAgZm9yIChqIGluIDE6bndhdmVzKSB7CiAgICAgIGRmX3dvcmtzX3cgPC0gZGZfd29ya3NbZGZfd29ya3Mkd29ya3NfeWVhciA+PSB3YXZlc1tbal1dWzFdICYKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRmX3dvcmtzJHdvcmtzX3llYXIgPD0gd2F2ZXNbW2pdXVsyXSwgXQogICAgICBmb3IgKGkgaW4gMTpucm93KGRmX3dvcmtzX3cpKSB7CiAgICAgICAgZWdvIDwtIGRmX3dvcmtzX3ckd29ya3NfYXV0aG9yW2ldW1sxXV0kYXVfaWRbMV0KICAgICAgICBhbHRlcnMgPC0gZGZfd29ya3NfdyR3b3Jrc19hdXRob3JbaV1bWzFdXSRhdV9pZFstMV0KICAgICAgICBpZiAoc3VtKGlkcyAlaW4lIGVnbykgPiAwICYgc3VtKGlkcyAlaW4lIGFsdGVycykgPiAwKSB7CiAgICAgICAgICBuZXRzW2osIHdoaWNoKGlkcyAlaW4lIGVnbyksIHdoaWNoKGlkcyAlaW4lIGFsdGVycyldIDwtIDEKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9CiAgCiAgaWYgKHR5cGUgPT0gImxhc3QiKSB7CiAgICBmb3IgKGogaW4gMTpud2F2ZXMpIHsKICAgICAgZGZfd29ya3NfdyA8LSBkZl93b3Jrc1tkZl93b3JrcyR3b3Jrc195ZWFyID49IHdhdmVzW1tqXV1bMV0gJgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGZfd29ya3Mkd29ya3NfeWVhciA8PSB3YXZlc1tbal1dWzJdLCBdCiAgICAgIGZvciAoaSBpbiAxOm5yb3coZGZfd29ya3NfdykpIHsKICAgICAgICBlZ28gPC0gcmV2KGRmX3dvcmtzX3ckd29ya3NfYXV0aG9yW2ldW1sxXV0kYXVfaWQpWzFdCiAgICAgICAgYWx0ZXJzIDwtIHJldihkZl93b3Jrc193JHdvcmtzX2F1dGhvcltpXVtbMV1dJGF1X2lkKVstMV0KICAgICAgICBpZiAoc3VtKGlkcyAlaW4lIGVnbykgPiAwICYgc3VtKGlkcyAlaW4lIGFsdGVycykgPiAwKSB7CiAgICAgICAgICBuZXRzW2osIHdoaWNoKGlkcyAlaW4lIGVnbyksIHdoaWNoKGlkcyAlaW4lIGFsdGVycyldIDwtIDEKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9CiAgCiAgaWYgKHR5cGUgPT0gImFsbCIpIHsKICAgIGZvciAoaiBpbiAxOm53YXZlcykgewogICAgICBkZl93b3Jrc193IDwtIGRmX3dvcmtzW2RmX3dvcmtzJHdvcmtzX3llYXIgPj0gd2F2ZXNbW2pdXVsxXSAmCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZl93b3JrcyR3b3Jrc195ZWFyIDw9IHdhdmVzW1tqXV1bMl0sIF0KICAgICAgZm9yIChpIGluIDE6bnJvdyhkZl93b3Jrc193KSkgewogICAgICAgIGVnb3MgPC0gZGZfd29ya3NfdyR3b3Jrc19hdXRob3JbaV1bWzFdXSRhdV9pZAogICAgICAgIGlmIChzdW0oaWRzICVpbiUgZWdvcykgPiAwKSB7CiAgICAgICAgICBuZXRzW2osIHdoaWNoKGlkcyAlaW4lIGVnb3MpLCB3aGljaChpZHMgJWluJSBlZ29zKV0gPC0gMQogICAgICAgIH0KICAgICAgfQogICAgfQogIH0KICAKICAjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAjIFN0ZXAgNTogb3V0cHV0CiAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgb3V0cHV0IDwtIGxpc3QoKQogIG91dHB1dCRkYXRhIDwtIHNjaG9sYXJzX3NlbAogIG91dHB1dCRuZXRzIDwtIG5ldHMKICBvdXRwdXQkZGVtb2dyYXBoaWNzIDwtIGRlbW9ncmFwaGljc19hbGwgICMgaW5jbHVkZXMgZ2VuZGVyIGlmIHBhc3NlZCBpbgogIAogIHJldHVybihvdXRwdXQpCn0KYGBgCiMjIyBvdXRwdXQKYGBge3J9CnJlc3VsdF9nZW5kZXIyIDwtIGZjb2xuZXRfZ2VuZGVyKAogIGRhdGEgPSBzY2hvbGFycywKICBkZW1vZ3JhcGhpY3MgPSBkZl9zY2hvbGFyc19nZW5kZXIsCiAgd2F2ZXMgPSBsaXN0KGMoMjAxNSwgMjAxOCksIGMoMjAxOSwyMDIzKSksCiAgdHlwZT0gImZpcnN0IgopCgojIFZpZXcgZ2VuZGVyIGluZm8KaGVhZChyZXN1bHRfZ2VuZGVyMiRkZW1vZ3JhcGhpY3NbLCBjKCJhdV9pZCIsICJmaXJzdG5hbWUiLCAiZ2VuZGVyIildKQpgYGAKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIyBGaXJzdCBhbmFseXNlcwo8YnI+CgojIyMgQ2hlY2sgd2F2ZXMKYGBge3J9CndhdmUxIDwtIHJlc3VsdF9nZW5kZXIyJG5ldHNbMSwsXQp3YXZlMiA8LSByZXN1bHRfZ2VuZGVyMiRuZXRzWzIsLF0KCiMgZmlsdGVyIG91dCB0aGUgd2F2ZXMgb2YgdGhlIG9iamVjdDogd2UgbmVlZCB0byBjaGVjayBvdXIgaW5wdXQKZGltKHdhdmUxKQpkaW0od2F2ZTIpCgojIHlvdSBuZWVkIHRvIGhhdmUgMCBtaXNzaW5nIHZhbHVlczoKc3VtKGlzLm5hKHdhdmUxKSkKc3VtKGlzLm5hKHdhdmUyKSkKCiNjaGVjayB0aGUgZGlhZ29uYWw6IGFsbCBwbGFjZXMgc2hvdWxkIGJlIDAKc3VtKGRpYWcod2F2ZTEpPT0wKQpzdW0oZGlhZyh3YXZlMik9PTApCgojIGEgZmV3IHBlb3BsZSBkaWQgd29yayB3aXRoIHRoZW1zZWx2ZXM6CmRpYWcod2F2ZTEpIDwtIDAKZGlhZyh3YXZlMikgPC0gMAoKIyBldmVyeXRoaW5nIHNob3VsZCBiZSAxIG9yIDA6CnN1bSh3YXZlMT4xKQpzdW0od2F2ZTI+MSkKCiMgY2hlY2sgaWYgaXQncyBub3QgZW1wdHk6IHRoZXJlIGFyZSBwZW9wbGUgd2l0aCAxJ3MKc3VtKHdhdmUxPjApCnN1bSh3YXZlMj4wKQoKCm5ldF9nZW5kZXIgPC0gYXJyYXkoZGF0YSA9IGMod2F2ZTEsIHdhdmUyKSwgZGltID0gYyhkaW0od2F2ZTEpLCAyKSkKIyBuZXRfZ2VuZGVyCgojIGRlcGVuZGVudApuZXQyIDwtIHNpZW5hRGVwZW5kZW50KG5ldF9nZW5kZXIpCgojIGluZGVwZW5kZW50IHZhcmlhYmxlcwpnZW5kZXIgPC0gcmVzdWx0X2dlbmRlcjIkZGVtb2dyYXBoaWNzJGdlbmRlcgoKZ2VuZGVyIDwtIGlmZWxzZShnZW5kZXI9PSJmZW1hbGUiLDEsMCkKZ2VuZGVyIDwtIGNvQ292YXIoZ2VuZGVyKQoKI2dlbmRlcgoKIyBDcmVhdGUgc2llbmEgZGF0YSBvYmplY3QKbXlkYXRhMyA8LSBzaWVuYURhdGFDcmVhdGUobmV0MiwgZ2VuZGVyKQpteWRhdGEzCmBgYAoKYGBge3J9Cm15ZWZmIDwtZ2V0RWZmZWN0cyhteWRhdGEzKQoKaWZlbHNlKCFkaXIuZXhpc3RzKCJyZXN1bHRzIiksIGRpci5jcmVhdGUoInJlc3VsdHMiKSwgRkFMU0UpCnByaW50MDFSZXBvcnQobXlkYXRhMywgbW9kZWxuYW1lID0gIi4vcmVzdWx0cy9zb2NfaW5pdDIiKQpgYGAKCiMjIyBJbmNsdWRlIGVmZmVjdHMKYGBge3IsIGV2YWwgPSBGfQpteWVmZiA8LSBpbmNsdWRlRWZmZWN0cyhteWVmZiwgZWdvWCwgaW50ZXJhY3Rpb24xID0gImdlbmRlciIsIHR5cGUgPSAiZXZhbCIsIGluY2x1ZGUgPSBUKSAgIAoKIyBjYW4gYWxsc28gYWRkIHRoZSBhbHRYIHRvIHRoZSBlcXVhdGlvbgpteWVmZiA8LSBzZXRFZmZlY3QobXllZmYsIGFsdFgsIGludGVyYWN0aW9uMSA9ICJnZW5kZXIiLCBpbmNsdWRlID0gVCkgIAoKIyBjYW4gYWxzbyBhZGQgZWdvWGFsdFgKbXllZmYgPC0gc2V0RWZmZWN0KG15ZWZmLCBlZ29YYWx0WCwgaW50ZXJhY3Rpb24xID0gImdlbmRlciIsIGluY2x1ZGUgPSBUKQoKbXlBbGdvcml0aG0gPC0gc2llbmFBbGdvcml0aG1DcmVhdGUocHJvam5hbWUgPSAic29jX2luaXQiKQphbnNNMSA8LSBzaWVuYTA3KG15QWxnb3JpdGhtLCBkYXRhID0gbXlkYXRhMywgZWZmZWN0cyA9IG15ZWZmLCByZXR1cm5EZXBzID0gVFJVRSkKIyBpZiBuZWNlc3NhcnkgZXN0aW1hdGUgYWdhaW4hICBhbnNNMSA8LSBzaWVuYTA3KG15QWxnb3JpdGhtLCBkYXRhID0gbXlkYXRhLCBlZmZlY3RzID0gbXllZmYsCiMgcHJldkFucyA9IGFuc00xLCByZXR1cm5EZXBzPVRSVUUpCmFuc00xCmBgYAo8YnI+ClRoaXMgbWVhbnMgdGhhdDoKCk91dGRlZ3JlZToJU2lnbmlmaWNhbnQgYW5kIG5lZ2F0aXZlIChiID0gLTQuMTY5NywgU0UgPSAwLjA4MjcpOiB0aGVyZSBpcyBhbiBvdmVyYWxsIHRlbmRlbmN5IG5vdCB0byBmb3JtIHRpZXMgKG1vc3QgcGVvcGxlIGNvbGxhYm9yYXRlIHdpdGggZmV3IG90aGVycykKClJlY2lwcm9jaXR5OiBTaWduaWZpY2FudCBhbmQgcG9zaXRpdmUgKGIgPSAzLjcxNTAsIFNFID0gMC4xNzA4KTogbXV0dWFsIGNvbGxhYm9yYXRpb25zIGFyZSBtb3JlIGxpa2VseTogaWYgQSBjby1hdXRob3JzIHdpdGggQiwgQiBpcyBtb3JlIGxpa2VseSB0byBjby1hdXRob3Igd2l0aCBBLgoKR2VuZGVyIGVnbzoJU2lnbmlmaWNhbnQgYW5kIHBvc2l0aXZlIChiID0gMC40MDk0LCBTRSA9IDAuMTU0OSk6IEJlaW5nIGEgd29tYW4gaW5jcmVhc2VzIHRoZSBsaWtlbGlob29kIG9mIGluaXRpYXRpbmcgY28tYXV0aG9yc2hpcHMuCQoKR2VuZGVyIGFsdGVyOiBTaWduaWZpY2FudCBhbmQgbmVnYXRpdmUgKGIgPSAtMC4yOTA4LCBTRSA9IDAuMDgyNik6CUJlaW5nIGEgd29tYW4gZGVjcmVhc2VzIHRoZSBsaWtlbGlob29kIG9mIGJlaW5nIGNob3NlbiBhcyBhIGNvLWF1dGhvci4KCkdlbmRlciBlZ28gw5cgZ2VuZGVyIGFsdGVyOiBTaWduaWZpY2FudCBhbmQgcG9zaXRpdmUgKGIgPSAwLjUwNjksIFNFID0gMC4xNjI2KSA6IFN1Z2dlc3RzIHNhbWUtZ2VuZGVyIGNvbGxhYm9yYXRpb25zIGFyZSBtb3JlIGxpa2VseSB0aGFuIGNyb3NzLWdlbmRlciBvbmVzLgoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIyBSU2llbm5hIGNoYXB0ZXJzCjxicj4KCiMjIyBDaGFwdGVyIDIKVGhlIGRlZmluaW5nIGNoYXJhY3RlcmlzdGljIG9mIFN0b2NoYXN0aWMgQWN0b3ItT3JpZW50ZWQgTW9kZWxzIGlzIHRoZWlyIOKAmGFjdG9yLW9yaWVudGVk4oCZIG5hdHVyZQp3aGljaCBtZWFucyB0aGF0IHRoZXkgbW9kZWwgY2hhbmdlIGZyb20gdGhlIHBlcnNwZWN0aXZlIG9mIHRoZSBhY3RvcnMgKG5vZGVzKS4KCkZvciBuZXR3b3JrIGV2b2x1dGlvbiwgdGhyZWUgY29uY2VwdHVhbCBmdW5jdGlvbnMgbWF5IGJlIHVzZWQ6IGV2YWx1YXRpb24sIGNyZWF0aW9uLCBhbmQgZW5kb3dtZW50LiBUaGVzZSBkaWZmZXIgaW4gd2hldGhlciBvbmUgbW9kZWxzIGFsbCB0aWUgcHJlc2VuY2UgKGV2YWx1YXRpb24pLCBqdXN0IHRpZSBmb3JtYXRpb24gKGNyZWF0aW9uKSwgb3IgdGllIG1haW50ZW5hbmNlIChlbmRvd21lbnQpLiAKCkVmZmVjdHM6IFRoZXNlIGFyZSB0aGUgbW9kZWxlZCBpbmZsdWVuY2VzIChleHBsYW5hdG9yeSBmYWN0b3JzKSBvbiBjaGFuZ2UuCgogIC0gU3RydWN0dXJhbCBlZmZlY3RzIChlbmRvZ2Vub3VzKSBlLmcuIHJlY2lwcm9jaXR5LCB0cmFuc2l0aXZpdHkKICAKICAtIENvdmFyaWF0ZSBlZmZlY3RzIChleG9nZW5vdXMpIGUuZy4gc2ltaWxhcml0eSwgYXR0cmlidXRlIG9mIHNlbmRlci9yZWNlaXZlcgogIAogIC0gSW50ZXJhY3Rpb24gZWZmZWN0cyAoY29tYmluYXRpb25zKSBlLmcuIGludGVyYWN0aW9uIG9mIHN0cnVjdHVyZSBhbmQgY292YXJpYXRlIAogIApFc3RpbWF0aW9uIHByb2NlZHVyZToKClJTaWVuYSB1c2VzIHRoZSBmdW5jdGlvbiBzaWVuYTA3IHRvIGVzdGltYXRlIHBhcmFtZXRlcnMuVGhlIGdvYWwgaXMgdGhhdCB0aGUgbW9kZWwtaW1wbGllZCAoZXhwZWN0ZWQpIG5ldHdvcmsvYmVoYXZpb3JhbCBzdGF0aXN0aWNzIG1hdGNoIG9ic2VydmVkIHN0YXRpc3RpY3MuIAoKVGhlIGVzdGltYXRpb24gcHJvY2VlZHMgaW4gcGhhc2VzOgoKICAtIEVzdGltYXRlIHNlbnNpdGl2aXR5IG9mIHN0YXRpc3RpY3MgdG8gcGFyYW1ldGVycwogIAogIC0gSXRlcmF0aXZlIHVwZGF0ZXM6IHNpbXVsYXRlIG5ldHdvcmtzLCBjb21wdXRlIGRldmlhdGlvbnMsIGFkanVzdCBwYXJhbWV0ZXJzCiAgCiAgLSBDaGVjayBjb252ZXJnZW5jZTogd2hldGhlciBzaW11bGF0ZWQgc3RhdGlzdGljcyBhcmUgY2xvc2UgZW5vdWdoIHRvIG9ic2VydmVkIHRhcmdldHMKCklmIGNvbnZlcmdlbmNlIGNyaXRlcmlhIGFyZSBub3QgbWV0LCBlc3RpbWF0aW9uIG1heSBiZSByZXBlYXRlZCBvciByZWZpbmVkLiAKCjxicj4KIyMjIENoYXB0ZXIgNQoKSW4gbWFueSBhcHBsaWNhdGlvbnMsIGl04oCZcyBiZXN0IHRvIHN0YXJ0IHdpdGggYSBzaW1wbGUgYmFzZWxpbmUgbW9kZWwgKGUuZy4gaW5jbHVkaW5nIG9ubHkgY29yZSBzdHJ1Y3R1cmFsIGVmZmVjdHMgbGlrZSBvdXQtZGVncmVlIGFuZCByZWNpcHJvY2l0eSkuCgpGcm9tIHRoZXJlLCBhZGQgb3IgcmVtb3ZlIGVmZmVjdHMgKGluIHNtYWxsIHNldHMsIGUuZy4gMeKAkzMgYXQgYSB0aW1lKSwgYXNzZXNzaW5nIGNvbnZlcmdlbmNlLCBpbnRlcnByZXRhYmlsaXR5LCBhbmQgZml0IGF0IGVhY2ggc3RhZ2UuCgpJdCBpcyB3aXNlIHRvIGFsd2F5cyByZXRhaW4gY2VydGFpbiDigJxhbmNob3LigJ0gZWZmZWN0cyAoZS5nLiBvdXQtZGVncmVlIG9yIHJhdGUgcGFyYW1ldGVycykgZXZlbiBpZiB0aGV5IGFyZSBub3Qgc3RhdGlzdGljYWxseSBzaWduaWZpY2FudCwgYmVjYXVzZSB0aGV5IHN0YWJpbGl6ZSB0aGUgbW9kZWwgc3RydWN0dXJlLgoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIyBTZWNvbmQgYW5hbHlzZXMKCiMjIyB0cmFuc1RyaXAKVGhlcmUgYXJlIG1hbnkgU3RydWN0dXJhbCBlZmZlY3RzIHlvdSBjYW4gaW5jbHVkZS4gSSB0cmllZCBhcm91bmQgd2l0aCB0cmlhbmd1bGF0aW9uLCBidXQgSSBkaWQgbm90IHRoaW5rIGl0IHJlYWxseSBmaXQgbXkgZ2VuZGVyIHJlc2VhcmNoLiBJdCBjb3VsZCBiZSBpbnRlcmVzdGluZzogaWYgeW91IGhhdmUgQSAtPiBCIC0+IEMsIHdvdWxkIHRoZSBnZW5kZXIgb2YgQiBpbXBhY3Qgd2hldGhlciBBIC0+IEMgd291bGQgY29sbGFib3JhdGUuIAoKYGBge3IsIGV2YWw9Rn0KbXllZmYgPC0gaW5jbHVkZUVmZmVjdHMobXllZmYsIGVnb1gsIGludGVyYWN0aW9uMSA9ICJnZW5kZXIiLCB0eXBlID0gImV2YWwiLCBpbmNsdWRlID0gVCkgCm15ZWZmIDwtIHNldEVmZmVjdChteWVmZiwgYWx0WCwgaW50ZXJhY3Rpb24xID0gImdlbmRlciIsIGluY2x1ZGUgPSBUKSAKbXllZmYgPC0gc2V0RWZmZWN0KG15ZWZmLCBlZ29YYWx0WCwgaW50ZXJhY3Rpb24xID0gImdlbmRlciIsIGluY2x1ZGUgPSBUKQoKbXllZmYgPC0gaW5jbHVkZUVmZmVjdHMobXllZmYsIHRyYW5zVHJpcCwgaW5jbHVkZSA9IFQpCm15ZWZmIDwtIGluY2x1ZGVFZmZlY3RzKG15ZWZmLCB0cmFuc1RyaXBYLCBpbnRlcmFjdGlvbjEgPSAiZ2VuZGVyIiwgdHlwZSA9ICJldmFsIiwgaW5jbHVkZSA9IFQpCgpteUFsZ29yaXRobSA8LSBzaWVuYUFsZ29yaXRobUNyZWF0ZShwcm9qbmFtZSA9ICJzb2NfaW5pdCIpCmFuc00yIDwtIHNpZW5hMDcobXlBbGdvcml0aG0sIGRhdGEgPSBteWRhdGEzLCBlZmZlY3RzID0gbXllZmYsIHJldHVybkRlcHMgPSBUUlVFKQojIGlmIG5lY2Vzc2FyeSBlc3RpbWF0ZSBhZ2FpbiEgIGFuc00xIDwtIHNpZW5hMDcobXlBbGdvcml0aG0sIGRhdGEgPSBteWRhdGEsIGVmZmVjdHMgPSBteWVmZiwKIyBwcmV2QW5zID0gYW5zTTEsIHJldHVybkRlcHM9VFJVRSkKYW5zTTIKCmBgYApUaGUgbmV0d29yayBzaG93cyBhIHNpZ25pZmljYW50IHRlbmRlbmN5IHRvd2FyZCB0cmFuc2l0aXZlIGNsb3N1cmUgKGIgPSAxLjkxNjYsIFNFID0gMC4xNzg2KSwgbWVhbmluZyB0aGF0IOKAnGZyaWVuZHMgb2YgZnJpZW5kc+KAnSBhcmUgbW9yZSBsaWtlbHkgdG8gYmVjb21lIGNvbm5lY3RlZC4gVGhlIGVmZmVjdCBvZiB0cmFuc2l0aXZlIHRyaXBsZXRzIG1vZGVyYXRlZCBieSB0aGUgaW50ZXJtZWRpYXRlIHBlcnNvbuKAmXMgZ2VuZGVyIGlzIG5vdCBzaWduaWZpY2FudCAoYiA9IDAuMTU4MCwgU0UgPSAwLjUyOTQpLCBzdWdnZXN0aW5nIHRoYXQgdGhlIGdlbmRlciBvZiB0aGUgaW50ZXJtZWRpYXRlIGhhcyBubyBpbmZsdWVuY2Ugb24gd2hldGhlciB0cmlhZHMgY2xvc2UuIElmIHlvdSBoYXZlIEEgLT4gQiAtPiBDLCB0aGUgZ2VuZGVyIG9mIEIgZG9lcyBub3QgaW1wYWN0IHdoZXRoZXIgQSAtPiBDIHdvdWxkIGNvbGxhYm9yYXRlLiAKCjxicj4KCkZvcm11bGE6CiFbXShpbWFnZXMvVHJpYWQucG5nKQo8YnI+CkZvciBhbGwgYWx0ZXJzIGosIGlmIGVnbyBpIGlzIHRpZWQgdG8gYW4gaW50ZXJtZWRpYXJ5IGggd2hvIGlzIGEgd29tYW4gKG1hbGUgPSAwLCBmZW1hbGUgPSAxKSBhbmQgaW50ZXJtZWRpYXJ5IGggaGFzIGEgY29ubmVjdGlvbiB0byBhbHRlciBqLCBhbmQgYWx0ZXIgaiBoYXMgYSBjb25uZWN0aW9uIHRvIGVnbyBpLCB0aGVuIHRoYXQgY29uZmlndXJhdGlvbiBhZGRzIDEgdG8gaSdzIHRyYW5zVHJpcFggc3RhdGlzdGljLgoKPGJyPgoKIyMjIGluUG9wCmBgYHtyLCBldmFsID0gRn0KIyBmaXJzdCBwdXQgdGhlIHRyaWFkaWMgZWZmZWN0cyBvbjogZG8gbm90IGluY2x1ZGUKbXllZmYgPC0gaW5jbHVkZUVmZmVjdHMobXllZmYsIHRyYW5zVHJpcCwgaW5jbHVkZSA9IEYpCm15ZWZmIDwtIGluY2x1ZGVFZmZlY3RzKG15ZWZmLCB0cmFuc1RyaXBYLCBpbnRlcmFjdGlvbjEgPSAiZ2VuZGVyIiwgdHlwZSA9ICJldmFsIiwgaW5jbHVkZSA9IEYpCgojIEdldCBlZ28sIGFsdCBhbmQgZWdvYWx0IGVmZmVjdHMKbXllZmYgPC0gaW5jbHVkZUVmZmVjdHMobXllZmYsIGVnb1gsIGludGVyYWN0aW9uMSA9ICJnZW5kZXIiLCB0eXBlID0gImV2YWwiLCBpbmNsdWRlID0gVCkgCm15ZWZmIDwtIHNldEVmZmVjdChteWVmZiwgYWx0WCwgaW50ZXJhY3Rpb24xID0gImdlbmRlciIsIGluY2x1ZGUgPSBUKSAKbXllZmYgPC0gc2V0RWZmZWN0KG15ZWZmLCBlZ29YYWx0WCwgaW50ZXJhY3Rpb24xID0gImdlbmRlciIsIGluY2x1ZGUgPSBUKQoKbXllZmYgPC0gaW5jbHVkZUVmZmVjdHMobXllZmYsIGluUG9wLCBpbmNsdWRlID0gVCkKCm15ZWZmIDwtIGluY2x1ZGVJbnRlcmFjdGlvbihteWVmZiwgZWdvWCwgaW5Qb3AsIGludGVyYWN0aW9uMSA9IGMoImdlbmRlciIsICIiKSwgdHlwZSA9ICJldmFsIiwgaW5jbHVkZSA9IFQpCgpteUFsZ29yaXRobSA8LSBzaWVuYUFsZ29yaXRobUNyZWF0ZShwcm9qbmFtZSA9ICJzb2NfaW5pdCIpCmFuc00zIDwtIHNpZW5hMDcobXlBbGdvcml0aG0sIGRhdGEgPSBteWRhdGEzLCBlZmZlY3RzID0gbXllZmYsIHJldHVybkRlcHMgPSBUUlVFKQojIGlmIG5lY2Vzc2FyeSBlc3RpbWF0ZSBhZ2FpbiEgIGFuc00xIDwtIHNpZW5hMDcobXlBbGdvcml0aG0sIGRhdGEgPSBteWRhdGEsIGVmZmVjdHMgPSBteWVmZiwKIyBwcmV2QW5zID0gYW5zTTEsIHJldHVybkRlcHM9VFJVRSkKYW5zTTMKYGBgCjxicj4KCkkgYW0gbm90IHN1cmUgd2hldGhlciBJIGFtIGludGVycHJldGluZyB0aGlzIGNvcnJlY3RseSBidXQ6IAoKVGhlIGluZGVncmVlLXBvcHVsYXJpdHkgZWZmZWN0IHdhcyBzaWduaWZpY2FudCBhbmQgcG9zaXRpdmUgKGIgPSAwLjE5LCBTRSA9IDAuMDMpIHVnZ2VzdGluZyB0aGF0IGFjdG9ycyB3aG8gcmVjZWl2ZWQgbW9yZSBub21pbmF0aW9ucyB3ZXJlIG1vcmUgbGlrZWx5IHRvIGF0dHJhY3QgYWRkaXRpb25hbCBvbmVzLgoKV29tZW4gaW4gdGhlIG5ldHdvcmsgaW5pdGlhbGx5IHJlY2VpdmVkIGZld2VyIHRpZXMgdGhhbiBtZW4sIGJ1dCBhZnRlciBpbmNsdWRpbmcgdGhlIGluZGVncmVl4oCTcG9wdWxhcml0eSBlZmZlY3QsIHRoZSBtYWluIGdlbmRlciBlZmZlY3RzIHdlcmUgbm8gbG9uZ2VyIHNpZ25pZmljYW50IChnZW5kZXIgZWdvOiBiID0gMC4zMywgU0UgPSAwLjIyOyBnZW5kZXIgYWx0ZXI6IGIgPSDigJMwLjE0LCBTRSA9IDAuMTMpLiBUaGlzIHN1Z2dlc3RzIHRoYXQgdGhlIG9ic2VydmVkIGdlbmRlciBkaWZmZXJlbmNlcyB3ZXJlIGxhcmdlbHkgZXhwbGFpbmVkIGJ5IHBvcHVsYXJpdHkgcmF0aGVyIHRoYW4gZ2VuZGVyIGl0c2VsZi4gVGhlIGludGVyYWN0aW9uIGJldHdlZW4gZ2VuZGVyIGVnbyBhbmQgaW5kZWdyZWXigJNwb3B1bGFyaXR5IChiID0gMC4wMywgU0UgPSAwLjA2KSB3YXMgYWxzbyBub24tc2lnbmlmaWNhbnQsIGluZGljYXRpbmcgdGhhdCBwb3B1bGFyaXR5IGluZmx1ZW5jZXMgdGllIGZvcm1hdGlvbiBzaW1pbGFybHkgZm9yIG1lbiBhbmQgd29tZW4uIE92ZXJhbGwsIGdlbmRlciBkaWZmZXJlbmNlcyBpbiB0aWUgaW5pdGlhdGlvbiBhcHBlYXIgdG8gc3RlbSBmcm9tIHN0cnVjdHVyYWwgbmV0d29yayBkeW5hbWljc+KAlHN1Y2ggYXMgYSBwcmVmZXJlbmNlIGZvciBjb25uZWN0aW5nIHRvIGFscmVhZHkgcG9wdWxhciBhbHRlcnMsIGFtb25nIHdob20gbWVuIGFyZSBsaWtlbHkgb3ZlcnJlcHJlc2VudGVk4oCUcmF0aGVyIHRoYW4gZnJvbSBkaXJlY3QgZ2VuZGVyLWJhc2VkIGVmZmVjdHMuCgo8YnI+ClRoZSBmb3JtdWxhOgohW10oaW1hZ2VzL2luUG9wLnBuZykKRm9yIGFsbCBhbHRlcidzIChqKTogaWYgYW4gZWdvIChpKSBoYXMgYSB0aWUgdG8gYW4gYWx0ZXIgKGopIHN1bSBmb3IgdGhlIGFsdGVyIChqKSB0aGUgbnVtYmVyIG9mIGl0cyBhbHRlcnMgKGgpIHdoaWNoIGFyZSBub3QgZWdvIChpKSwgYW5kIHRoZW4geW91IGRvIHBsdXMgb25lIGJlY2F1c2UgeW91IGFsc28gd2FudCB0byBjb3VudCB0aGUgb25lIGNvbm5lY3Rpb24gdG8gZWdvIChpKS4gCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("Create_Dataset.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
