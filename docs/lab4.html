<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Mylène Husson" />


<title>Journal 1</title>

<script src="site_libs/header-attrs-2.29/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/clipboard-1.7.1/clipboard.min.js"></script>
<link href="site_libs/primer-tooltips-1.4.0/build.css" rel="stylesheet" />
<link href="site_libs/klippy-0.0.0.9500/css/klippy.min.css" rel="stylesheet" />
<script src="site_libs/klippy-0.0.0.9500/js/klippy.min.js"></script>
<link href="site_libs/font-awesome-6.5.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    My journal
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="lab1.html">Week 1</a>
    </li>
    <li>
      <a href="lab2.html">Week 2</a>
    </li>
    <li>
      <a href="lab3.html">Week 3</a>
    </li>
    <li>
      <a href="lab4.html">Week 4</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://mcmhusson.github.io/labjournal_mylene/">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Journal 1</h1>
<h4 class="author">Mylène Husson</h4>

</div>


<pre class="r"><code>library(knitr)
library(tidyverse)
library(scholar)
library(openalexR)
library(rvest)
library(jsonlite)
library(httr)
library(rvest)
library(reshape2)
library(xml2)
library(openxlsx)
library(polite)
library(igraph)
library(sna)
library(genderizeR)
library(RSelenium)
library(netstat)
library(pingr)

#load the functions you need from the packages
fpackage.check &lt;- function(packages) {
  lapply(packages, FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  })
}

fsave &lt;- function(x, file = NULL, location = &quot;./data/processed/&quot;) {
  ifelse(!dir.exists(&quot;data&quot;), dir.create(&quot;data&quot;), FALSE)
  ifelse(!dir.exists(&quot;data/processed&quot;), dir.create(&quot;data/processed&quot;), FALSE)
  if (is.null(file))
    file = deparse(substitute(x))
  datename &lt;- substr(gsub(&quot;[:-]&quot;, &quot;&quot;, Sys.time()), 1, 8)
  totalname &lt;- paste(location, datename, file, &quot;.rda&quot;, sep = &quot;&quot;)
  save(x, file = totalname)  #need to fix if file is reloaded as input name, not as x. 
}

fload &lt;- function(filename) {
  load(filename)
  get(ls()[ls() != &quot;filename&quot;])
}

fshowdf &lt;- function(x, ...) {
  knitr::kable(x, digits = 2, &quot;html&quot;, ...) %&gt;%
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;)) %&gt;%
    kableExtra::scroll_box(width = &quot;100%&quot;, height = &quot;300px&quot;)
}</code></pre>
<script>
  addClassKlippyTo("pre.r, pre.markdown");
  addKlippy('right', 'top', 'auto', '1', 'Copy code', 'Copied!');
</script>
<p>Last compiled on October, 2025 <br></p>
<hr />
<div id="week-4" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Week 4</h1>
<p><br></p>
<hr />
<div id="workshop" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Workshop</h2>
<p>Today we are going to look at network visualisation. It is important
you look at the data</p>
<p><br></p>
<hr />
<div id="zacharys-karate-club" class="section level3" number="1.1.1">
<h3><span class="header-section-number">1.1.1</span> Zachary’s karate
club</h3>
<pre class="r"><code>require(igraph)

# Visualise Zachary&#39;s network
g &lt;- make_graph(&quot;Zachary&quot;)
plot(g)</code></pre>
<p><img src="lab4_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<pre class="r"><code># you see differences between ego&#39;s in centralities, it&#39;s a complete network, undirected and unweighted ties.
# Perhaps something like friendship or something.

gmat &lt;- as_adjacency_matrix(g, type = &quot;both&quot;, sparse = FALSE)
#gmat

# Descriptives
# number of nodes: vcount(g)

# number of edges: ecount(g)

# the number of degrees: heavliy skewed
igraph::degree(g)</code></pre>
<pre><code>##  [1] 16  9 10  6  3  4  4  4  5  2  3  1  2  5  2  2  2  2  2  3  2  2  2  5  3
## [26]  3  2  4  3  4  4  6 12 17</code></pre>
<pre class="r"><code># transitivity
# be aware that directed graphs are considered as undirected. but g is undirected.
igraph::transitivity(g, type = c(&quot;localundirected&quot;), isolates = c(&quot;NaN&quot;, &quot;zero&quot;))</code></pre>
<pre><code>##  [1] 0.1500000 0.3333333 0.2444444 0.6666667 0.6666667 0.5000000 0.5000000
##  [8] 1.0000000 0.5000000 0.0000000 0.6666667       NaN 1.0000000 0.6000000
## [15] 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 0.3333333 1.0000000
## [22] 1.0000000 1.0000000 0.4000000 0.3333333 0.3333333 1.0000000 0.1666667
## [29] 0.3333333 0.6666667 0.5000000 0.2000000 0.1969697 0.1102941</code></pre>
<pre class="r"><code># betweenness: 1 and 34 very high
igraph::betweenness(g, directed = FALSE)</code></pre>
<pre><code>##  [1] 231.0714286  28.4785714  75.8507937   6.2880952   0.3333333  15.8333333
##  [7]  15.8333333   0.0000000  29.5293651   0.4476190   0.3333333   0.0000000
## [13]   0.0000000  24.2158730   0.0000000   0.0000000   0.0000000   0.0000000
## [19]   0.0000000  17.1468254   0.0000000   0.0000000   0.0000000   9.3000000
## [25]   1.1666667   2.0277778   0.0000000  11.7920635   0.9476190   1.5428571
## [31]   7.6095238  73.0095238  76.6904762 160.5515873</code></pre>
<pre class="r"><code># dyad census: igraph::dyad.census(g)
# igraph::triad.census(g)
# I will use sna because it shows the names of the triads as well.

igraph::transitivity(g, type = &quot;global&quot;)</code></pre>
<pre><code>## [1] 0.2556818</code></pre>
<pre class="r"><code>#sna::gtrans(gmat)

triad_g &lt;- data.frame(sna::triad.census(gmat))

# for transitivity on network level: divide number of transitive triads by all possible transitive triads

# X300 is the variable of transative triads, and the X201 is the one in which one person is linked with two persons, who are not linked: so it&#39;s a possible transitive triad. 
# therefore, X201 + X300 are all possible transititve triads.
transitivity_g &lt;- (3 * triad_g$X300)/(triad_g$X201 + 3 * triad_g$X300)
transitivity_g</code></pre>
<pre><code>## [1] 0.2556818</code></pre>
</div>
<div id="ashwin-presentation" class="section level3" number="1.1.2">
<h3><span class="header-section-number">1.1.2</span> Ashwin
Presentation</h3>
<p>You can look at network properties (descriptives, graph), Ashwin
looks at how we can use networks to explain certain phenomena.</p>
<p>RQ: How are social and intellectual relations structured and given
shape within research universities?</p>
<p>Not only about social relationships, but also intellectual thinking.
Do shared interests lead to collaborations, or do collaborations lead to
similar interests.</p>
<pre><code>- structure:    collaboration leads to similar interests
- culture:      scientists with similar interests find each other
- homophily:    similar backgrounds lead to similar interest and collaboration
- propinquity:  physical proximity leads to similar research interest and collaboration</code></pre>
<p>If you have a huge network of ties, you can see if there are people
who do not work together with people you are observing, but that does
not mean they don’t collaborate at all.</p>
</div>
<div id="continuing-with-zacharys-karate-club" class="section level3"
number="1.1.3">
<h3><span class="header-section-number">1.1.3</span> Continuing with
Zachary’s karate club</h3>
<pre class="r"><code># make sizes proportional to betweenness score
V(g)$size = igraph::betweenness(g, normalized = TRUE, directed = FALSE)* 60 + 10  #after some trial and error
plot(g, mode = &quot;undirected&quot;)</code></pre>
<p><img src="lab4_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<pre class="r"><code># the + 10 is added because some nodes have a 0 on betweenness and dissapear in the graph without +10
# the * 60 makes the differences bigger

# now: we want no overlap 
set.seed(2345)
l &lt;- layout_with_mds(g)  #https://igraph.org/r/doc/layout_with_mds.html
plot(g, layout = l)</code></pre>
<p><img src="lab4_files/figure-html/unnamed-chunk-3-2.png" width="672" /></p>
<pre class="r"><code># now you see three clusters: around 33/34, around 1 and around 3, and the cluser around 3 you didn&#39;t see before. And that the two biggest clusters are not linked directly.

# you can then say that specific ones should be further apart:
# l  #let us take a look at the coordinates
l[1, 1] &lt;- 4
l[34, 1] &lt;- -3.5
plot(g, layout = l)</code></pre>
<p><img src="lab4_files/figure-html/unnamed-chunk-3-3.png" width="672" /></p>
<pre class="r"><code># 1 and 34 are most connected, perhaps they are the owners/masters from the karate club
# and maybe they are having an argument and are therefore not connected</code></pre>
<p>Looking at Jochem’s paper about twitter and the people in parliament.
You see pollarisation: people mostly interact with people in their own
party (clusters)</p>
<p><br></p>
<hr />
</div>
</div>
<div id="homework" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> Homework</h2>
<p>Update your Research Questions</p>
<ol style="list-style-type: decimal">
<li><p>Visualize your social network data: Static (a) Interactive and/or
dynamic (b)</p></li>
<li><p>Be prepared to discuss the results of your network visualization
next week.</p></li>
<li><p>Continue writing your data section and your result
section</p></li>
<li><p>Update your lab journal / website</p></li>
</ol>
<p><br></p>
<hr />
</div>
<div id="friday-september-19th" class="section level2" number="1.3">
<h2><span class="header-section-number">1.3</span> Friday September
19th</h2>
<p><br></p>
<hr />
<div id="try-assigning-gender" class="section level3" number="1.3.1">
<h3><span class="header-section-number">1.3.1</span> Try assigning
gender:</h3>
<pre class="r"><code># from the tutorial
df &lt;- fload(file = &quot;./data/20230627df_names.rda&quot;)

firstname &lt;- df |&gt;
  distinct(firstname) |&gt; #only unique
  select(firstname) |&gt; #only this variable
  filter(firstname != &quot;&quot;) |&gt; #remove empty
  pull(firstname) #save as chr

test &lt;- genderizeAPI(firstname[1])
#test$response

length(firstname)</code></pre>
<pre><code>## [1] 595</code></pre>
<pre class="r"><code>df_genderizer &lt;- data.frame(matrix(ncol = 4, nrow = length(firstname)))
colnames(df_genderizer) &lt;- c(&quot;count&quot;, &quot;name&quot;, &quot;gender&quot;, &quot;probability&quot;)

#for (i in 1:length(firstname)) {
#    Sys.sleep(0.1)
#    df_genderizer[i, ] &lt;- genderizeAPI(firstname[i])$response
#}
#colnames(df_genderizer) &lt;- c(&quot;count&quot;, &quot;name&quot;, &quot;gender&quot;, &quot;probability&quot;)
#df_genderizer$name &lt;- firstname  #so we know which names are not found. 

#df_genderizer

# now we have a probability score, but you can also dummify it
#df_genderizer &lt;- df_genderizer[df_genderizer$probability &gt; 0.9, ]

#df_genderizer &lt;- subset(df_genderizer, select = c(&quot;name&quot;, &quot;gender&quot;))

#fshowdf(df_genderizer)
#View(df_genderizer)

#df |&gt;
#    left_join(df_genderizer, by = c(firstname = &quot;name&quot;)) -&gt; df_gender

#fshowdf(df_gender)

#fsave(df_gender)</code></pre>
</div>
<div id="assigned-gender" class="section level3" number="1.3.2">
<h3><span class="header-section-number">1.3.2</span> Assigned
gender</h3>
<pre class="r"><code># Rvest table object inspecteren en die geven aan het 
name = &quot;Erik&quot;

# Build URL robustly
base_url &lt;- &quot;https://nvb.meertens.knaw.nl/naam/is&quot;
name_url &lt;- paste0(base_url, &quot;/&quot;, name)

table &lt;- read_html(name_url) |&gt;
  html_element(&quot;table&quot;) |&gt;
  html_table()


# Replace &quot;--&quot; with &quot;0&quot; everywhere
table[table == &quot;--&quot;] &lt;- &quot;0&quot;

# Now you can safely convert to numeric
val_male   &lt;- as.numeric(table[2, 3])
val_female &lt;- as.numeric(table[6, 3])

# Compare and assign gender
gender &lt;- if (val_male &gt; val_female) {
  &quot;male&quot;
} else if (val_female &gt;= val_male) {
  &quot;female&quot;
} else {
  NA
}

gender</code></pre>
<pre><code>## [1] &quot;male&quot;</code></pre>
</div>
<div id="gender-function" class="section level3" number="1.3.3">
<h3><span class="header-section-number">1.3.3</span> Gender
Function</h3>
<pre class="r"><code>my_genderizer &lt;- function(name) {
  name &lt;- gsub(&quot;^/+|/+$&quot;, &quot;&quot;, name)
  
  # Build URL
  base_url &lt;- &quot;https://nvb.meertens.knaw.nl/naam/is&quot;
  name_url &lt;- paste0(base_url, &quot;/&quot;, name)
  
  # Try reading table
  table &lt;- tryCatch(
    read_html(name_url) |&gt;
      html_element(&quot;table&quot;) |&gt;
      html_table(),
    error = function(e) NULL
  )
  
  if (is.null(table)) return(NA)  # return NA if no table found
  
  # Replace &quot;--&quot; with &quot;0&quot;
  table[table == &quot;--&quot;] &lt;- &quot;0&quot;
  
  # Convert to numeric
  val_male   &lt;- suppressWarnings(as.numeric(table[2, 3]))
  val_female &lt;- suppressWarnings(as.numeric(table[6, 3]))
  
  # Decide gender
  if (is.na(val_male) &amp; is.na(val_female)) {
    gender &lt;- NA
  } else if (val_male &gt; val_female) {
    gender &lt;- &quot;male&quot;
  } else if (val_female &gt; val_male) {
    gender &lt;- &quot;female&quot;
  } else {
    gender &lt;- NA
  }
  
  return(gender)
}

soc_pol &lt;- readxl::read_excel(&quot;/Users/mylenehusson/Desktop/SocialNetworks/labjournal_mylene/data/20240419Scholarid_soc_pol.xlsx&quot;)
soc_pol_small &lt;- soc_pol[1:20, ]
soc_pol_small$gender &lt;- NA

soc_pol_small &lt;- soc_pol_small |&gt;
  mutate(firstname = word(Naam, 1)) 

for (i in seq_len(nrow(soc_pol_small))) {
  name &lt;- soc_pol_small$firstname[i]
  gender &lt;- my_genderizer(name)

  soc_pol_small$gender[i] &lt;- gender
}

#View(soc_pol_small)</code></pre>
</div>
<div id="the-nomination-network" class="section level3" number="1.3.4">
<h3><span class="header-section-number">1.3.4</span> The nomination
Network</h3>
<pre class="r"><code># load in the data
scholars &lt;- fload(&quot;./data/processed/scholars_20240924.rda&quot;)

# select scholars
# (sociology, RU)
demographics &lt;- do.call(rbind.data.frame, scholars$demographics)
demographics &lt;- demographics %&gt;%
    mutate(Universiteit1.22 = replace(Universiteit1.22, is.na(Universiteit1.22), &quot;&quot;), Universiteit2.22 = replace(Universiteit2.22,
        is.na(Universiteit2.22), &quot;&quot;), Universiteit1.24 = replace(Universiteit1.24, is.na(Universiteit1.24),
        &quot;&quot;), Universiteit2.24 = replace(Universiteit2.24, is.na(Universiteit2.24), &quot;&quot;), discipline.22 = replace(discipline.22,
        is.na(discipline.22), &quot;&quot;), discipline.24 = replace(discipline.24, is.na(discipline.24), &quot;&quot;))

sample &lt;- which((demographics$Universiteit1.22 == &quot;RU&quot; | demographics$Universiteit2.22 == &quot;RU&quot; | demographics$Universiteit1.24 ==
    &quot;RU&quot; | demographics$Universiteit2.24 == &quot;RU&quot;) &amp; (demographics$discipline.22 == &quot;sociology&quot; | demographics$discipline.24 ==
    &quot;sociology&quot;))

demographics_soc &lt;- demographics[sample, ]
scholars_sel &lt;- lapply(scholars, &quot;[&quot;, sample)

# construct the empty adjacency matrix
ids &lt;- demographics_soc$au_id
wave2 &lt;- wave1 &lt;- matrix(0, nrow = length(ids), ncol = length(ids), dimnames = list(ids, ids))

# filter works
works &lt;- scholars_sel$work

works_id &lt;- unlist(lapply(works, function(l) l$id))
works_author &lt;- unlist(lapply(works, function(l) l$author), recursive = FALSE)
works_year &lt;- unlist(lapply(works, function(l) l$publication_year), recursive = FALSE)

df_works &lt;- tibble(works_id, works_author, works_year)

dups &lt;- which(duplicated(works_id))

df_works &lt;- df_works[-dups, ]
df_works_w2 &lt;- df_works[df_works$works_year &gt; 2019, ]

# undirected
# undirected
for (i in 1:nrow(df_works_w2)) {
    egos &lt;- df_works_w2$works_author[i][[1]]$au_id

    if (sum(ids %in% egos) &gt; 0) {
        wave2[which(ids %in% egos), which(ids %in% egos)] &lt;- 1
    }
}</code></pre>
<p><br></p>
<p>Now one function to rule them all:</p>
<pre class="r"><code>fcolnet &lt;- function(data = scholars, university = &quot;RU&quot;, discipline = &quot;sociology&quot;, waves = list(c(2015,
    2018), c(2019, 2023)), type = c(&quot;first&quot;)) {

    # step 1
    demographics &lt;- do.call(rbind.data.frame, data$demographics)
    demographics &lt;- demographics %&gt;%
        mutate(Universiteit1.22 = replace(Universiteit1.22, is.na(Universiteit1.22), &quot;&quot;), Universiteit2.22 = replace(Universiteit2.22,
            is.na(Universiteit2.22), &quot;&quot;), Universiteit1.24 = replace(Universiteit1.24, is.na(Universiteit1.24),
            &quot;&quot;), Universiteit2.24 = replace(Universiteit2.24, is.na(Universiteit2.24), &quot;&quot;), discipline.22 = replace(discipline.22,
            is.na(discipline.22), &quot;&quot;), discipline.24 = replace(discipline.24, is.na(discipline.24), &quot;&quot;))

    sample &lt;- which((demographics$Universiteit1.22 %in% university | demographics$Universiteit2.22 %in%
        university | demographics$Universiteit1.24 %in% university | demographics$Universiteit2.24 %in%
        university) &amp; (demographics$discipline.22 %in% discipline | demographics$discipline.24 %in% discipline))

    demographics_soc &lt;- demographics[sample, ]
    scholars_sel &lt;- lapply(scholars, &quot;[&quot;, sample)

    # step 2
    ids &lt;- demographics_soc$au_id
    nwaves &lt;- length(waves)
    nets &lt;- array(0, dim = c(nwaves, length(ids), length(ids)), dimnames = list(wave = 1:nwaves, ids,
        ids))
    dimnames(nets)

    # step 3
    df_works &lt;- tibble(works_id = unlist(lapply(scholars_sel$work, function(l) l$id)), works_author = unlist(lapply(scholars_sel$work,
        function(l) l$author), recursive = FALSE), works_year = unlist(lapply(scholars_sel$work, function(l) l$publication_year),
        recursive = FALSE))

    df_works &lt;- df_works[!duplicated(df_works), ]

    # step 4
    if (type == &quot;first&quot;) {
        for (j in 1:nwaves) {
            df_works_w &lt;- df_works[df_works$works_year &gt;= waves[[j]][1] &amp; df_works$works_year &lt;= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego &lt;- df_works_w$works_author[i][[1]]$au_id[1]
                alters &lt;- df_works_w$works_author[i][[1]]$au_id[-1]
                if (sum(ids %in% ego) &gt; 0 &amp; sum(ids %in% alters) &gt; 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] &lt;- 1
                }
            }
        }
    }

    if (type == &quot;last&quot;) {
        for (j in 1:nwaves) {
            df_works_w &lt;- df_works[df_works$works_year &gt;= waves[[j]][1] &amp; df_works$works_year &lt;= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego &lt;- rev(df_works_w$works_author[i][[1]]$au_id)[1]
                alters &lt;- rev(df_works_w$works_author[i][[1]]$au_id)[-1]
                if (sum(ids %in% ego) &gt; 0 &amp; sum(ids %in% alters) &gt; 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] &lt;- 1
                }
            }
        }
    }

    if (type == &quot;all&quot;) {
        for (j in 1:nwaves) {
            df_works_w &lt;- df_works[df_works$works_year &gt;= waves[[j]][1] &amp; df_works$works_year &lt;= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                egos &lt;- df_works_w$works_author[i][[1]]$au_id
                if (sum(ids %in% egos) &gt; 0) {
                  nets[j, which(ids %in% egos), which(ids %in% egos)] &lt;- 1
                }
            }
        }
    }
    output &lt;- list()
    output$data &lt;- scholars_sel
    output$nets &lt;- nets
    return(output)
}</code></pre>
</div>
<div id="assigning-gender-to-demographics" class="section level3"
number="1.3.5">
<h3><span class="header-section-number">1.3.5</span> Assigning Gender to
demographics</h3>
<pre class="r"><code>df_scholars &lt;- do.call(rbind, scholars$demographics)

#View(df_scholars)

df_scholars2 &lt;- df_scholars |&gt;
  mutate(firstname = word(Naam, 1))  # extract first names

df_scholars2$gender &lt;- NA_character_  # initialize gender column

for (i in seq_len(nrow(df_scholars2))) {
  name &lt;- df_scholars2$firstname[i]
  gender &lt;- my_genderizer(name)
  
  df_scholars2$gender[i] &lt;- gender
  Sys.sleep(0.06)  # pause between requests
}

#View(df_scholars2)</code></pre>
<p><br></p>
<hr />
</div>
</div>
<div id="thursday-oktober-2nd" class="section level2" number="1.4">
<h2><span class="header-section-number">1.4</span> Thursday Oktober
2nd</h2>
<p><br></p>
<hr />
<div id="add-gender-demographics-to-the-big-data" class="section level3"
number="1.4.1">
<h3><span class="header-section-number">1.4.1</span> Add gender
demographics to the big data</h3>
<p>Now add the new demographics including gender to the big data</p>
<pre class="r"><code>fcolnet_gender &lt;- function(data = scholars,
                           university = &quot;RU&quot;,
                           discipline = &quot;sociology&quot;,
                           waves = list(c(2015, 2018), c(2019, 2023)),
                           type = c(&quot;first&quot;),
                           demographics = NULL) {
  
  # -------------------------
  # Step 1: demographics
  # -------------------------
  if (is.null(demographics)) {
    demographics &lt;- do.call(rbind.data.frame, data$demographics)
  }
  
  demographics &lt;- demographics %&gt;%
    mutate(
      Universiteit1.22 = replace(Universiteit1.22, is.na(Universiteit1.22), &quot;&quot;),
      Universiteit2.22 = replace(Universiteit2.22, is.na(Universiteit2.22), &quot;&quot;),
      Universiteit1.24 = replace(Universiteit1.24, is.na(Universiteit1.24), &quot;&quot;),
      Universiteit2.24 = replace(Universiteit2.24, is.na(Universiteit2.24), &quot;&quot;),
      discipline.22    = replace(discipline.22,    is.na(discipline.22),    &quot;&quot;),
      discipline.24    = replace(discipline.24,    is.na(discipline.24),    &quot;&quot;)
    )
  
  sample &lt;- which(
    (demographics$Universiteit1.22 %in% university |
       demographics$Universiteit2.22 %in% university |
       demographics$Universiteit1.24 %in% university |
       demographics$Universiteit2.24 %in% university) &amp;
      (demographics$discipline.22 %in% discipline |
         demographics$discipline.24 %in% discipline)
  )
  
  demographics_soc &lt;- demographics[sample, ]
  scholars_sel &lt;- lapply(data, &quot;[&quot;, sample)
  
  # -------------------------
  # Step 2: initialize network array
  # -------------------------
  ids &lt;- demographics_soc$au_id
  nwaves &lt;- length(waves)
  nets &lt;- array(
    0,
    dim = c(nwaves, length(ids), length(ids)),
    dimnames = list(wave = 1:nwaves, ids, ids)
  )
  
  # -------------------------
  # Step 3: works dataframe
  # -------------------------
  df_works &lt;- tibble(
    works_id     = unlist(lapply(scholars_sel$work, function(l) l$id)),
    works_author = unlist(lapply(scholars_sel$work, function(l) l$author), recursive = FALSE),
    works_year   = unlist(lapply(scholars_sel$work, function(l) l$publication_year), recursive = FALSE)
  )
  
  df_works &lt;- df_works[!duplicated(df_works), ]
  
  # -------------------------
  # Step 4: build networks
  # -------------------------
  if (type == &quot;first&quot;) {
    for (j in 1:nwaves) {
      df_works_w &lt;- df_works[df_works$works_year &gt;= waves[[j]][1] &amp;
                               df_works$works_year &lt;= waves[[j]][2], ]
      for (i in 1:nrow(df_works_w)) {
        ego &lt;- df_works_w$works_author[i][[1]]$au_id[1]
        alters &lt;- df_works_w$works_author[i][[1]]$au_id[-1]
        if (sum(ids %in% ego) &gt; 0 &amp; sum(ids %in% alters) &gt; 0) {
          nets[j, which(ids %in% ego), which(ids %in% alters)] &lt;- 1
        }
      }
    }
  }
  
  if (type == &quot;last&quot;) {
    for (j in 1:nwaves) {
      df_works_w &lt;- df_works[df_works$works_year &gt;= waves[[j]][1] &amp;
                               df_works$works_year &lt;= waves[[j]][2], ]
      for (i in 1:nrow(df_works_w)) {
        ego &lt;- rev(df_works_w$works_author[i][[1]]$au_id)[1]
        alters &lt;- rev(df_works_w$works_author[i][[1]]$au_id)[-1]
        if (sum(ids %in% ego) &gt; 0 &amp; sum(ids %in% alters) &gt; 0) {
          nets[j, which(ids %in% ego), which(ids %in% alters)] &lt;- 1
        }
      }
    }
  }
  
  if (type == &quot;all&quot;) {
    for (j in 1:nwaves) {
      df_works_w &lt;- df_works[df_works$works_year &gt;= waves[[j]][1] &amp;
                               df_works$works_year &lt;= waves[[j]][2], ]
      for (i in 1:nrow(df_works_w)) {
        egos &lt;- df_works_w$works_author[i][[1]]$au_id
        if (sum(ids %in% egos) &gt; 0) {
          nets[j, which(ids %in% egos), which(ids %in% egos)] &lt;- 1
        }
      }
    }
  }
  
  # -------------------------
  # Step 5: output
  # -------------------------
  output &lt;- list()
  output$data &lt;- scholars_sel
  output$nets &lt;- nets
  output$demographics &lt;- demographics_soc  # includes gender if passed in
  
  return(output)
}</code></pre>
</div>
<div id="see-if-it-works" class="section level3" number="1.4.2">
<h3><span class="header-section-number">1.4.2</span> See if it
works:</h3>
<pre class="r"><code>result_gender &lt;- fcolnet_gender(
  data = scholars,
  university = &quot;RU&quot;,
  discipline = &quot;sociology&quot;,
  demographics = df_scholars2
)

# Now you can access gender info in the output
head(result_gender$demographics[, c(&quot;au_id&quot;, &quot;firstname&quot;, &quot;gender&quot;)])</code></pre>
<pre><code>## # A tibble: 6 × 3
##   au_id                            firstname  gender
##   &lt;chr&gt;                            &lt;chr&gt;      &lt;chr&gt; 
## 1 https://openalex.org/A5011326378 Ana        female
## 2 https://openalex.org/A5014129369 Ronald     male  
## 3 https://openalex.org/A5023395007 Katia      female
## 4 https://openalex.org/A5068642001 Hidde      male  
## 5 https://openalex.org/A5074062335 Lonneke    female
## 6 https://openalex.org/A5018242597 Lieselotte female</code></pre>
</div>
<div id="visualisation-of-the-network" class="section level3"
number="1.4.3">
<h3><span class="header-section-number">1.4.3</span> Visualisation of
the network</h3>
<pre class="r"><code># adjacency matrix for first wave, can get the second one by making it a 2
adj_mat &lt;- result_gender$nets[1,,]

# create igraph object
g &lt;- graph_from_adjacency_matrix(adj_mat, mode = &quot;undirected&quot;)</code></pre>
<pre><code>## Warning: The `adjmatrix` argument of `graph_from_adjacency_matrix()` must be symmetric
## with mode = &quot;undirected&quot; as of igraph 1.6.0.
## ℹ Use mode = &quot;max&quot; to achieve the original behavior.
## This warning is displayed once every 8 hours.
## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was
## generated.</code></pre>
<pre class="r"><code># make sure vertex order matches demographics order
gender_vec &lt;- result_gender$demographics$gender
names(gender_vec) &lt;- result_gender$demographics$au_id

# assign gender attribute to igraph
V(g)$gender &lt;- gender_vec[V(g)$name]

# I am not sure whether people with NA are still in my network so I added a grey option???
V(g)$color &lt;- ifelse(V(g)$gender == &quot;male&quot;, &quot;blue&quot;,
                     ifelse(V(g)$gender == &quot;female&quot;, &quot;orange&quot;, &quot;grey&quot;))

# assign node size by betweenness centrality
V(g)$size &lt;- igraph::betweenness(g, normalized = TRUE, directed = FALSE) * 60 + 7

# final plot
plot(
  g,
  vertex.label = NA,
  edge.arrow.size = 0.4,
  main = &quot;Co-authorship Network RU Sociology (Wave 1)&quot;
)

# add legend
legend(
  &quot;topright&quot;,
  legend = c(&quot;Men&quot;, &quot;Women&quot;, &quot;Unknown&quot;),
  col    = c(&quot;blue&quot;, &quot;orange&quot;, &quot;grey&quot;),
  pch    = 19,
  pt.cex = 1.5,
  bty    = &quot;n&quot;
)</code></pre>
<p><img src="lab4_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
</div>
<div id="calculate-the-properties" class="section level3"
number="1.4.4">
<h3><span class="header-section-number">1.4.4</span> Calculate the
properties</h3>
<pre class="r"><code># number of nodes and edges
vcount(g)</code></pre>
<pre><code>## [1] 50</code></pre>
<pre class="r"><code>ecount(g)</code></pre>
<pre><code>## [1] 35</code></pre>
<pre class="r"><code># density
edge_density(g)</code></pre>
<pre><code>## [1] 0.02857143</code></pre>
<pre class="r"><code># average degree
degree &lt;- igraph::degree(g)
mean(degree)</code></pre>
<pre><code>## [1] 1.4</code></pre>
<pre class="r"><code># betweenness centrality
head(igraph::betweenness(g))</code></pre>
<pre><code>## https://openalex.org/A5011326378 https://openalex.org/A5014129369 
##                                0                                7 
## https://openalex.org/A5023395007 https://openalex.org/A5068642001 
##                                0                                0 
## https://openalex.org/A5074062335 https://openalex.org/A5018242597 
##                                0                                0</code></pre>
<pre class="r"><code># transivitivity: clustering
transitivity(g, type = &quot;global&quot;)</code></pre>
<pre><code>## [1] 0.08256881</code></pre>
<p><br></p>
<p>Let’s if men or women have a higher degree of centrality:</p>
<pre class="r"><code># degree of each node
deg &lt;- igraph::degree(g, mode = &quot;all&quot;) # for undirected

# gender attribute
gender &lt;- V(g)$gender

# combine into a dataframe
network_df &lt;- data.frame(
  au_id = V(g)$name,
  gender = gender,
  degree = deg
)

network_df |&gt;
  group_by(gender) |&gt;
  summarise(
    mean_degree = mean(degree),
    median_degree = median(degree),
    max_degree = max(degree),
    n = n()
  )</code></pre>
<pre><code>## # A tibble: 2 × 5
##   gender mean_degree median_degree max_degree     n
##   &lt;chr&gt;        &lt;dbl&gt;         &lt;dbl&gt;      &lt;dbl&gt; &lt;int&gt;
## 1 female       0.577             0          3    26
## 2 male         2.29              2          8    24</code></pre>
<p>In this network, male scholars tend to have higher degree centrality
than female scholars.</p>
<p>Many female nodes are isolated or weakly connected, while males have
more collaborations.</p>
</div>
</div>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiSm91cm5hbCAxIgojYmlibGlvZ3JhcGh5OiByZWZlcmVuY2VzLmJpYgphdXRob3I6ICJNeWzDqG5lIEh1c3NvbiIKLS0tCgpgYGB7ciwgZWNobz1UUlVFLCByZXN1bHRzPSdoaWRlJywgbWVzc2FnZT1GQUxTRSwgd2FybmluZz1GQUxTRX0KbGlicmFyeShrbml0cikKbGlicmFyeSh0aWR5dmVyc2UpCmxpYnJhcnkoc2Nob2xhcikKbGlicmFyeShvcGVuYWxleFIpCmxpYnJhcnkocnZlc3QpCmxpYnJhcnkoanNvbmxpdGUpCmxpYnJhcnkoaHR0cikKbGlicmFyeShydmVzdCkKbGlicmFyeShyZXNoYXBlMikKbGlicmFyeSh4bWwyKQpsaWJyYXJ5KG9wZW54bHN4KQpsaWJyYXJ5KHBvbGl0ZSkKbGlicmFyeShpZ3JhcGgpCmxpYnJhcnkoc25hKQpsaWJyYXJ5KGdlbmRlcml6ZVIpCmxpYnJhcnkoUlNlbGVuaXVtKQpsaWJyYXJ5KG5ldHN0YXQpCmxpYnJhcnkocGluZ3IpCgojbG9hZCB0aGUgZnVuY3Rpb25zIHlvdSBuZWVkIGZyb20gdGhlIHBhY2thZ2VzCmZwYWNrYWdlLmNoZWNrIDwtIGZ1bmN0aW9uKHBhY2thZ2VzKSB7CiAgbGFwcGx5KHBhY2thZ2VzLCBGVU4gPSBmdW5jdGlvbih4KSB7CiAgICBpZiAoIXJlcXVpcmUoeCwgY2hhcmFjdGVyLm9ubHkgPSBUUlVFKSkgewogICAgICBpbnN0YWxsLnBhY2thZ2VzKHgsIGRlcGVuZGVuY2llcyA9IFRSVUUpCiAgICAgIGxpYnJhcnkoeCwgY2hhcmFjdGVyLm9ubHkgPSBUUlVFKQogICAgfQogIH0pCn0KCmZzYXZlIDwtIGZ1bmN0aW9uKHgsIGZpbGUgPSBOVUxMLCBsb2NhdGlvbiA9ICIuL2RhdGEvcHJvY2Vzc2VkLyIpIHsKICBpZmVsc2UoIWRpci5leGlzdHMoImRhdGEiKSwgZGlyLmNyZWF0ZSgiZGF0YSIpLCBGQUxTRSkKICBpZmVsc2UoIWRpci5leGlzdHMoImRhdGEvcHJvY2Vzc2VkIiksIGRpci5jcmVhdGUoImRhdGEvcHJvY2Vzc2VkIiksIEZBTFNFKQogIGlmIChpcy5udWxsKGZpbGUpKQogICAgZmlsZSA9IGRlcGFyc2Uoc3Vic3RpdHV0ZSh4KSkKICBkYXRlbmFtZSA8LSBzdWJzdHIoZ3N1YigiWzotXSIsICIiLCBTeXMudGltZSgpKSwgMSwgOCkKICB0b3RhbG5hbWUgPC0gcGFzdGUobG9jYXRpb24sIGRhdGVuYW1lLCBmaWxlLCAiLnJkYSIsIHNlcCA9ICIiKQogIHNhdmUoeCwgZmlsZSA9IHRvdGFsbmFtZSkgICNuZWVkIHRvIGZpeCBpZiBmaWxlIGlzIHJlbG9hZGVkIGFzIGlucHV0IG5hbWUsIG5vdCBhcyB4LiAKfQoKZmxvYWQgPC0gZnVuY3Rpb24oZmlsZW5hbWUpIHsKICBsb2FkKGZpbGVuYW1lKQogIGdldChscygpW2xzKCkgIT0gImZpbGVuYW1lIl0pCn0KCmZzaG93ZGYgPC0gZnVuY3Rpb24oeCwgLi4uKSB7CiAga25pdHI6OmthYmxlKHgsIGRpZ2l0cyA9IDIsICJodG1sIiwgLi4uKSAlPiUKICAgIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpICU+JQogICAga2FibGVFeHRyYTo6c2Nyb2xsX2JveCh3aWR0aCA9ICIxMDAlIiwgaGVpZ2h0ID0gIjMwMHB4IikKfQoKYGBgCgpgYGB7ciBrbGlwcHksIGVjaG89RkFMU0UsIGluY2x1ZGU9VFJVRX0Ka2xpcHB5OjprbGlwcHkocG9zaXRpb24gPSBjKCd0b3AnLCAncmlnaHQnKSkKI2tsaXBweTo6a2xpcHB5KGNvbG9yID0gJ2RhcmtyZWQnKQoja2xpcHB5OjprbGlwcHkodG9vbHRpcF9tZXNzYWdlID0gJ0NsaWNrIHRvIGNvcHknLCB0b29sdGlwX3N1Y2Nlc3MgPSAnRG9uZScpCmBgYAoKTGFzdCBjb21waWxlZCBvbiBgciBmb3JtYXQoU3lzLnRpbWUoKSwgJyVCLCAlWScpYAo8YnI+CgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMgV2VlayA0Cjxicj4KCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyMgV29ya3Nob3AKClRvZGF5IHdlIGFyZSBnb2luZyB0byBsb29rIGF0IG5ldHdvcmsgdmlzdWFsaXNhdGlvbi4gSXQgaXMgaW1wb3J0YW50IHlvdSBsb29rIGF0IHRoZSBkYXRhCgo8YnI+CgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMjIyAgWmFjaGFyeeKAmXMga2FyYXRlIGNsdWIKCmBgYHtyfQpyZXF1aXJlKGlncmFwaCkKCiMgVmlzdWFsaXNlIFphY2hhcnkncyBuZXR3b3JrCmcgPC0gbWFrZV9ncmFwaCgiWmFjaGFyeSIpCnBsb3QoZykKCiMgeW91IHNlZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGVnbydzIGluIGNlbnRyYWxpdGllcywgaXQncyBhIGNvbXBsZXRlIG5ldHdvcmssIHVuZGlyZWN0ZWQgYW5kIHVud2VpZ2h0ZWQgdGllcy4KIyBQZXJoYXBzIHNvbWV0aGluZyBsaWtlIGZyaWVuZHNoaXAgb3Igc29tZXRoaW5nLgoKZ21hdCA8LSBhc19hZGphY2VuY3lfbWF0cml4KGcsIHR5cGUgPSAiYm90aCIsIHNwYXJzZSA9IEZBTFNFKQojZ21hdAoKIyBEZXNjcmlwdGl2ZXMKIyBudW1iZXIgb2Ygbm9kZXM6IHZjb3VudChnKQoKIyBudW1iZXIgb2YgZWRnZXM6IGVjb3VudChnKQoKIyB0aGUgbnVtYmVyIG9mIGRlZ3JlZXM6IGhlYXZsaXkgc2tld2VkCmlncmFwaDo6ZGVncmVlKGcpCgojIHRyYW5zaXRpdml0eQojIGJlIGF3YXJlIHRoYXQgZGlyZWN0ZWQgZ3JhcGhzIGFyZSBjb25zaWRlcmVkIGFzIHVuZGlyZWN0ZWQuIGJ1dCBnIGlzIHVuZGlyZWN0ZWQuCmlncmFwaDo6dHJhbnNpdGl2aXR5KGcsIHR5cGUgPSBjKCJsb2NhbHVuZGlyZWN0ZWQiKSwgaXNvbGF0ZXMgPSBjKCJOYU4iLCAiemVybyIpKQoKIyBiZXR3ZWVubmVzczogMSBhbmQgMzQgdmVyeSBoaWdoCmlncmFwaDo6YmV0d2Vlbm5lc3MoZywgZGlyZWN0ZWQgPSBGQUxTRSkKCiMgZHlhZCBjZW5zdXM6IGlncmFwaDo6ZHlhZC5jZW5zdXMoZykKIyBpZ3JhcGg6OnRyaWFkLmNlbnN1cyhnKQojIEkgd2lsbCB1c2Ugc25hIGJlY2F1c2UgaXQgc2hvd3MgdGhlIG5hbWVzIG9mIHRoZSB0cmlhZHMgYXMgd2VsbC4KCmlncmFwaDo6dHJhbnNpdGl2aXR5KGcsIHR5cGUgPSAiZ2xvYmFsIikKI3NuYTo6Z3RyYW5zKGdtYXQpCgp0cmlhZF9nIDwtIGRhdGEuZnJhbWUoc25hOjp0cmlhZC5jZW5zdXMoZ21hdCkpCgojIGZvciB0cmFuc2l0aXZpdHkgb24gbmV0d29yayBsZXZlbDogZGl2aWRlIG51bWJlciBvZiB0cmFuc2l0aXZlIHRyaWFkcyBieSBhbGwgcG9zc2libGUgdHJhbnNpdGl2ZSB0cmlhZHMKCiMgWDMwMCBpcyB0aGUgdmFyaWFibGUgb2YgdHJhbnNhdGl2ZSB0cmlhZHMsIGFuZCB0aGUgWDIwMSBpcyB0aGUgb25lIGluIHdoaWNoIG9uZSBwZXJzb24gaXMgbGlua2VkIHdpdGggdHdvIHBlcnNvbnMsIHdobyBhcmUgbm90IGxpbmtlZDogc28gaXQncyBhIHBvc3NpYmxlIHRyYW5zaXRpdmUgdHJpYWQuIAojIHRoZXJlZm9yZSwgWDIwMSArIFgzMDAgYXJlIGFsbCBwb3NzaWJsZSB0cmFuc2l0aXR2ZSB0cmlhZHMuCnRyYW5zaXRpdml0eV9nIDwtICgzICogdHJpYWRfZyRYMzAwKS8odHJpYWRfZyRYMjAxICsgMyAqIHRyaWFkX2ckWDMwMCkKdHJhbnNpdGl2aXR5X2cKYGBgCgojIyMgQXNod2luIFByZXNlbnRhdGlvbgoKWW91IGNhbiBsb29rIGF0IG5ldHdvcmsgcHJvcGVydGllcyAoZGVzY3JpcHRpdmVzLCBncmFwaCksIEFzaHdpbiBsb29rcyBhdCBob3cgd2UgY2FuIHVzZSBuZXR3b3JrcyB0byBleHBsYWluIGNlcnRhaW4gcGhlbm9tZW5hLiAKClJROiBIb3cgYXJlIHNvY2lhbCBhbmQgaW50ZWxsZWN0dWFsIHJlbGF0aW9ucyBzdHJ1Y3R1cmVkIGFuZCBnaXZlbiBzaGFwZSB3aXRoaW4gcmVzZWFyY2ggdW5pdmVyc2l0aWVzPwoKTm90IG9ubHkgYWJvdXQgc29jaWFsIHJlbGF0aW9uc2hpcHMsIGJ1dCBhbHNvIGludGVsbGVjdHVhbCB0aGlua2luZy4KRG8gc2hhcmVkIGludGVyZXN0cyBsZWFkIHRvIGNvbGxhYm9yYXRpb25zLCBvciBkbyBjb2xsYWJvcmF0aW9ucyBsZWFkIHRvIHNpbWlsYXIgaW50ZXJlc3RzLgoKICAgIC0gc3RydWN0dXJlOiAgICBjb2xsYWJvcmF0aW9uIGxlYWRzIHRvIHNpbWlsYXIgaW50ZXJlc3RzCiAgICAtIGN1bHR1cmU6ICAgICAgc2NpZW50aXN0cyB3aXRoIHNpbWlsYXIgaW50ZXJlc3RzIGZpbmQgZWFjaCBvdGhlcgogICAgLSBob21vcGhpbHk6ICAgIHNpbWlsYXIgYmFja2dyb3VuZHMgbGVhZCB0byBzaW1pbGFyIGludGVyZXN0IGFuZCBjb2xsYWJvcmF0aW9uCiAgICAtIHByb3BpbnF1aXR5OiAgcGh5c2ljYWwgcHJveGltaXR5IGxlYWRzIHRvIHNpbWlsYXIgcmVzZWFyY2ggaW50ZXJlc3QgYW5kIGNvbGxhYm9yYXRpb24KCklmIHlvdSBoYXZlIGEgaHVnZSBuZXR3b3JrIG9mIHRpZXMsIHlvdSBjYW4gc2VlIGlmIHRoZXJlIGFyZSBwZW9wbGUgd2hvIGRvIG5vdCB3b3JrIHRvZ2V0aGVyIHdpdGggcGVvcGxlIHlvdSBhcmUgb2JzZXJ2aW5nLCBidXQgdGhhdCBkb2VzIG5vdCBtZWFuIHRoZXkgZG9uJ3QgY29sbGFib3JhdGUgYXQgYWxsLiAKCiMjIyBDb250aW51aW5nIHdpdGggWmFjaGFyeeKAmXMga2FyYXRlIGNsdWIKCmBgYHtyfQojIG1ha2Ugc2l6ZXMgcHJvcG9ydGlvbmFsIHRvIGJldHdlZW5uZXNzIHNjb3JlClYoZykkc2l6ZSA9IGlncmFwaDo6YmV0d2Vlbm5lc3MoZywgbm9ybWFsaXplZCA9IFRSVUUsIGRpcmVjdGVkID0gRkFMU0UpKiA2MCArIDEwICAjYWZ0ZXIgc29tZSB0cmlhbCBhbmQgZXJyb3IKcGxvdChnLCBtb2RlID0gInVuZGlyZWN0ZWQiKQoKIyB0aGUgKyAxMCBpcyBhZGRlZCBiZWNhdXNlIHNvbWUgbm9kZXMgaGF2ZSBhIDAgb24gYmV0d2Vlbm5lc3MgYW5kIGRpc3NhcGVhciBpbiB0aGUgZ3JhcGggd2l0aG91dCArMTAKIyB0aGUgKiA2MCBtYWtlcyB0aGUgZGlmZmVyZW5jZXMgYmlnZ2VyCgojIG5vdzogd2Ugd2FudCBubyBvdmVybGFwIApzZXQuc2VlZCgyMzQ1KQpsIDwtIGxheW91dF93aXRoX21kcyhnKSAgI2h0dHBzOi8vaWdyYXBoLm9yZy9yL2RvYy9sYXlvdXRfd2l0aF9tZHMuaHRtbApwbG90KGcsIGxheW91dCA9IGwpCiMgbm93IHlvdSBzZWUgdGhyZWUgY2x1c3RlcnM6IGFyb3VuZCAzMy8zNCwgYXJvdW5kIDEgYW5kIGFyb3VuZCAzLCBhbmQgdGhlIGNsdXNlciBhcm91bmQgMyB5b3UgZGlkbid0IHNlZSBiZWZvcmUuIEFuZCB0aGF0IHRoZSB0d28gYmlnZ2VzdCBjbHVzdGVycyBhcmUgbm90IGxpbmtlZCBkaXJlY3RseS4KCiMgeW91IGNhbiB0aGVuIHNheSB0aGF0IHNwZWNpZmljIG9uZXMgc2hvdWxkIGJlIGZ1cnRoZXIgYXBhcnQ6CiMgbCAgI2xldCB1cyB0YWtlIGEgbG9vayBhdCB0aGUgY29vcmRpbmF0ZXMKbFsxLCAxXSA8LSA0CmxbMzQsIDFdIDwtIC0zLjUKcGxvdChnLCBsYXlvdXQgPSBsKQoKIyAxIGFuZCAzNCBhcmUgbW9zdCBjb25uZWN0ZWQsIHBlcmhhcHMgdGhleSBhcmUgdGhlIG93bmVycy9tYXN0ZXJzIGZyb20gdGhlIGthcmF0ZSBjbHViCiMgYW5kIG1heWJlIHRoZXkgYXJlIGhhdmluZyBhbiBhcmd1bWVudCBhbmQgYXJlIHRoZXJlZm9yZSBub3QgY29ubmVjdGVkCmBgYAoKTG9va2luZyBhdCBKb2NoZW0ncyBwYXBlciBhYm91dCB0d2l0dGVyIGFuZCB0aGUgcGVvcGxlIGluIHBhcmxpYW1lbnQuIApZb3Ugc2VlIHBvbGxhcmlzYXRpb246IHBlb3BsZSBtb3N0bHkgaW50ZXJhY3Qgd2l0aCBwZW9wbGUgaW4gdGhlaXIgb3duIHBhcnR5IChjbHVzdGVycykKCjxicj4KCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyMgSG9tZXdvcmsKClVwZGF0ZSB5b3VyIFJlc2VhcmNoIFF1ZXN0aW9ucwoKMS4gVmlzdWFsaXplIHlvdXIgc29jaWFsIG5ldHdvcmsgZGF0YTogU3RhdGljIChhKSBJbnRlcmFjdGl2ZSBhbmQvb3IgZHluYW1pYyAoYikKCjIuIEJlIHByZXBhcmVkIHRvIGRpc2N1c3MgdGhlIHJlc3VsdHMgb2YgeW91ciBuZXR3b3JrIHZpc3VhbGl6YXRpb24gbmV4dCB3ZWVrLgoKMy4gQ29udGludWUgd3JpdGluZyB5b3VyIGRhdGEgc2VjdGlvbiBhbmQgeW91ciByZXN1bHQgc2VjdGlvbgo0LiBVcGRhdGUgeW91ciBsYWIgam91cm5hbCAvIHdlYnNpdGUKCjxicj4KCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyMgRnJpZGF5IFNlcHRlbWJlciAxOXRoCgo8YnI+CgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMjIyBUcnkgYXNzaWduaW5nIGdlbmRlcjogCgpgYGB7cn0KIyBmcm9tIHRoZSB0dXRvcmlhbApkZiA8LSBmbG9hZChmaWxlID0gIi4vZGF0YS8yMDIzMDYyN2RmX25hbWVzLnJkYSIpCgpmaXJzdG5hbWUgPC0gZGYgfD4KICBkaXN0aW5jdChmaXJzdG5hbWUpIHw+ICNvbmx5IHVuaXF1ZQogIHNlbGVjdChmaXJzdG5hbWUpIHw+ICNvbmx5IHRoaXMgdmFyaWFibGUKICBmaWx0ZXIoZmlyc3RuYW1lICE9ICIiKSB8PiAjcmVtb3ZlIGVtcHR5CiAgcHVsbChmaXJzdG5hbWUpICNzYXZlIGFzIGNocgoKdGVzdCA8LSBnZW5kZXJpemVBUEkoZmlyc3RuYW1lWzFdKQojdGVzdCRyZXNwb25zZQoKbGVuZ3RoKGZpcnN0bmFtZSkKZGZfZ2VuZGVyaXplciA8LSBkYXRhLmZyYW1lKG1hdHJpeChuY29sID0gNCwgbnJvdyA9IGxlbmd0aChmaXJzdG5hbWUpKSkKY29sbmFtZXMoZGZfZ2VuZGVyaXplcikgPC0gYygiY291bnQiLCAibmFtZSIsICJnZW5kZXIiLCAicHJvYmFiaWxpdHkiKQoKI2ZvciAoaSBpbiAxOmxlbmd0aChmaXJzdG5hbWUpKSB7CiMgICAgU3lzLnNsZWVwKDAuMSkKIyAgICBkZl9nZW5kZXJpemVyW2ksIF0gPC0gZ2VuZGVyaXplQVBJKGZpcnN0bmFtZVtpXSkkcmVzcG9uc2UKI30KI2NvbG5hbWVzKGRmX2dlbmRlcml6ZXIpIDwtIGMoImNvdW50IiwgIm5hbWUiLCAiZ2VuZGVyIiwgInByb2JhYmlsaXR5IikKI2RmX2dlbmRlcml6ZXIkbmFtZSA8LSBmaXJzdG5hbWUgICNzbyB3ZSBrbm93IHdoaWNoIG5hbWVzIGFyZSBub3QgZm91bmQuIAoKI2RmX2dlbmRlcml6ZXIKCiMgbm93IHdlIGhhdmUgYSBwcm9iYWJpbGl0eSBzY29yZSwgYnV0IHlvdSBjYW4gYWxzbyBkdW1taWZ5IGl0CiNkZl9nZW5kZXJpemVyIDwtIGRmX2dlbmRlcml6ZXJbZGZfZ2VuZGVyaXplciRwcm9iYWJpbGl0eSA+IDAuOSwgXQoKI2RmX2dlbmRlcml6ZXIgPC0gc3Vic2V0KGRmX2dlbmRlcml6ZXIsIHNlbGVjdCA9IGMoIm5hbWUiLCAiZ2VuZGVyIikpCgojZnNob3dkZihkZl9nZW5kZXJpemVyKQojVmlldyhkZl9nZW5kZXJpemVyKQoKI2RmIHw+CiMgICAgbGVmdF9qb2luKGRmX2dlbmRlcml6ZXIsIGJ5ID0gYyhmaXJzdG5hbWUgPSAibmFtZSIpKSAtPiBkZl9nZW5kZXIKCiNmc2hvd2RmKGRmX2dlbmRlcikKCiNmc2F2ZShkZl9nZW5kZXIpCgpgYGAKCiMjIyBBc3NpZ25lZCBnZW5kZXIKYGBge3J9CiMgUnZlc3QgdGFibGUgb2JqZWN0IGluc3BlY3RlcmVuIGVuIGRpZSBnZXZlbiBhYW4gaGV0IApuYW1lID0gIkVyaWsiCgojIEJ1aWxkIFVSTCByb2J1c3RseQpiYXNlX3VybCA8LSAiaHR0cHM6Ly9udmIubWVlcnRlbnMua25hdy5ubC9uYWFtL2lzIgpuYW1lX3VybCA8LSBwYXN0ZTAoYmFzZV91cmwsICIvIiwgbmFtZSkKCnRhYmxlIDwtIHJlYWRfaHRtbChuYW1lX3VybCkgfD4KICBodG1sX2VsZW1lbnQoInRhYmxlIikgfD4KICBodG1sX3RhYmxlKCkKCgojIFJlcGxhY2UgIi0tIiB3aXRoICIwIiBldmVyeXdoZXJlCnRhYmxlW3RhYmxlID09ICItLSJdIDwtICIwIgoKIyBOb3cgeW91IGNhbiBzYWZlbHkgY29udmVydCB0byBudW1lcmljCnZhbF9tYWxlICAgPC0gYXMubnVtZXJpYyh0YWJsZVsyLCAzXSkKdmFsX2ZlbWFsZSA8LSBhcy5udW1lcmljKHRhYmxlWzYsIDNdKQoKIyBDb21wYXJlIGFuZCBhc3NpZ24gZ2VuZGVyCmdlbmRlciA8LSBpZiAodmFsX21hbGUgPiB2YWxfZmVtYWxlKSB7CiAgIm1hbGUiCn0gZWxzZSBpZiAodmFsX2ZlbWFsZSA+PSB2YWxfbWFsZSkgewogICJmZW1hbGUiCn0gZWxzZSB7CiAgTkEKfQoKZ2VuZGVyCgpgYGAKCiMjIyBHZW5kZXIgRnVuY3Rpb24KCmBgYHtyfQoKbXlfZ2VuZGVyaXplciA8LSBmdW5jdGlvbihuYW1lKSB7CiAgbmFtZSA8LSBnc3ViKCJeLyt8LyskIiwgIiIsIG5hbWUpCiAgCiAgIyBCdWlsZCBVUkwKICBiYXNlX3VybCA8LSAiaHR0cHM6Ly9udmIubWVlcnRlbnMua25hdy5ubC9uYWFtL2lzIgogIG5hbWVfdXJsIDwtIHBhc3RlMChiYXNlX3VybCwgIi8iLCBuYW1lKQogIAogICMgVHJ5IHJlYWRpbmcgdGFibGUKICB0YWJsZSA8LSB0cnlDYXRjaCgKICAgIHJlYWRfaHRtbChuYW1lX3VybCkgfD4KICAgICAgaHRtbF9lbGVtZW50KCJ0YWJsZSIpIHw+CiAgICAgIGh0bWxfdGFibGUoKSwKICAgIGVycm9yID0gZnVuY3Rpb24oZSkgTlVMTAogICkKICAKICBpZiAoaXMubnVsbCh0YWJsZSkpIHJldHVybihOQSkgICMgcmV0dXJuIE5BIGlmIG5vIHRhYmxlIGZvdW5kCiAgCiAgIyBSZXBsYWNlICItLSIgd2l0aCAiMCIKICB0YWJsZVt0YWJsZSA9PSAiLS0iXSA8LSAiMCIKICAKICAjIENvbnZlcnQgdG8gbnVtZXJpYwogIHZhbF9tYWxlICAgPC0gc3VwcHJlc3NXYXJuaW5ncyhhcy5udW1lcmljKHRhYmxlWzIsIDNdKSkKICB2YWxfZmVtYWxlIDwtIHN1cHByZXNzV2FybmluZ3MoYXMubnVtZXJpYyh0YWJsZVs2LCAzXSkpCiAgCiAgIyBEZWNpZGUgZ2VuZGVyCiAgaWYgKGlzLm5hKHZhbF9tYWxlKSAmIGlzLm5hKHZhbF9mZW1hbGUpKSB7CiAgICBnZW5kZXIgPC0gTkEKICB9IGVsc2UgaWYgKHZhbF9tYWxlID4gdmFsX2ZlbWFsZSkgewogICAgZ2VuZGVyIDwtICJtYWxlIgogIH0gZWxzZSBpZiAodmFsX2ZlbWFsZSA+IHZhbF9tYWxlKSB7CiAgICBnZW5kZXIgPC0gImZlbWFsZSIKICB9IGVsc2UgewogICAgZ2VuZGVyIDwtIE5BCiAgfQogIAogIHJldHVybihnZW5kZXIpCn0KCnNvY19wb2wgPC0gcmVhZHhsOjpyZWFkX2V4Y2VsKCIvVXNlcnMvbXlsZW5laHVzc29uL0Rlc2t0b3AvU29jaWFsTmV0d29ya3MvbGFiam91cm5hbF9teWxlbmUvZGF0YS8yMDI0MDQxOVNjaG9sYXJpZF9zb2NfcG9sLnhsc3giKQpzb2NfcG9sX3NtYWxsIDwtIHNvY19wb2xbMToyMCwgXQpzb2NfcG9sX3NtYWxsJGdlbmRlciA8LSBOQQoKc29jX3BvbF9zbWFsbCA8LSBzb2NfcG9sX3NtYWxsIHw+CiAgbXV0YXRlKGZpcnN0bmFtZSA9IHdvcmQoTmFhbSwgMSkpIAoKZm9yIChpIGluIHNlcV9sZW4obnJvdyhzb2NfcG9sX3NtYWxsKSkpIHsKICBuYW1lIDwtIHNvY19wb2xfc21hbGwkZmlyc3RuYW1lW2ldCiAgZ2VuZGVyIDwtIG15X2dlbmRlcml6ZXIobmFtZSkKCiAgc29jX3BvbF9zbWFsbCRnZW5kZXJbaV0gPC0gZ2VuZGVyCn0KCiNWaWV3KHNvY19wb2xfc21hbGwpCmBgYAoKIyMjIFRoZSBub21pbmF0aW9uIE5ldHdvcmsKCmBgYHtyfQojIGxvYWQgaW4gdGhlIGRhdGEKc2Nob2xhcnMgPC0gZmxvYWQoIi4vZGF0YS9wcm9jZXNzZWQvc2Nob2xhcnNfMjAyNDA5MjQucmRhIikKCiMgc2VsZWN0IHNjaG9sYXJzCiMgKHNvY2lvbG9neSwgUlUpCmRlbW9ncmFwaGljcyA8LSBkby5jYWxsKHJiaW5kLmRhdGEuZnJhbWUsIHNjaG9sYXJzJGRlbW9ncmFwaGljcykKZGVtb2dyYXBoaWNzIDwtIGRlbW9ncmFwaGljcyAlPiUKICAgIG11dGF0ZShVbml2ZXJzaXRlaXQxLjIyID0gcmVwbGFjZShVbml2ZXJzaXRlaXQxLjIyLCBpcy5uYShVbml2ZXJzaXRlaXQxLjIyKSwgIiIpLCBVbml2ZXJzaXRlaXQyLjIyID0gcmVwbGFjZShVbml2ZXJzaXRlaXQyLjIyLAogICAgICAgIGlzLm5hKFVuaXZlcnNpdGVpdDIuMjIpLCAiIiksIFVuaXZlcnNpdGVpdDEuMjQgPSByZXBsYWNlKFVuaXZlcnNpdGVpdDEuMjQsIGlzLm5hKFVuaXZlcnNpdGVpdDEuMjQpLAogICAgICAgICIiKSwgVW5pdmVyc2l0ZWl0Mi4yNCA9IHJlcGxhY2UoVW5pdmVyc2l0ZWl0Mi4yNCwgaXMubmEoVW5pdmVyc2l0ZWl0Mi4yNCksICIiKSwgZGlzY2lwbGluZS4yMiA9IHJlcGxhY2UoZGlzY2lwbGluZS4yMiwKICAgICAgICBpcy5uYShkaXNjaXBsaW5lLjIyKSwgIiIpLCBkaXNjaXBsaW5lLjI0ID0gcmVwbGFjZShkaXNjaXBsaW5lLjI0LCBpcy5uYShkaXNjaXBsaW5lLjI0KSwgIiIpKQoKc2FtcGxlIDwtIHdoaWNoKChkZW1vZ3JhcGhpY3MkVW5pdmVyc2l0ZWl0MS4yMiA9PSAiUlUiIHwgZGVtb2dyYXBoaWNzJFVuaXZlcnNpdGVpdDIuMjIgPT0gIlJVIiB8IGRlbW9ncmFwaGljcyRVbml2ZXJzaXRlaXQxLjI0ID09CiAgICAiUlUiIHwgZGVtb2dyYXBoaWNzJFVuaXZlcnNpdGVpdDIuMjQgPT0gIlJVIikgJiAoZGVtb2dyYXBoaWNzJGRpc2NpcGxpbmUuMjIgPT0gInNvY2lvbG9neSIgfCBkZW1vZ3JhcGhpY3MkZGlzY2lwbGluZS4yNCA9PQogICAgInNvY2lvbG9neSIpKQoKZGVtb2dyYXBoaWNzX3NvYyA8LSBkZW1vZ3JhcGhpY3Nbc2FtcGxlLCBdCnNjaG9sYXJzX3NlbCA8LSBsYXBwbHkoc2Nob2xhcnMsICJbIiwgc2FtcGxlKQoKIyBjb25zdHJ1Y3QgdGhlIGVtcHR5IGFkamFjZW5jeSBtYXRyaXgKaWRzIDwtIGRlbW9ncmFwaGljc19zb2MkYXVfaWQKd2F2ZTIgPC0gd2F2ZTEgPC0gbWF0cml4KDAsIG5yb3cgPSBsZW5ndGgoaWRzKSwgbmNvbCA9IGxlbmd0aChpZHMpLCBkaW1uYW1lcyA9IGxpc3QoaWRzLCBpZHMpKQoKIyBmaWx0ZXIgd29ya3MKd29ya3MgPC0gc2Nob2xhcnNfc2VsJHdvcmsKCndvcmtzX2lkIDwtIHVubGlzdChsYXBwbHkod29ya3MsIGZ1bmN0aW9uKGwpIGwkaWQpKQp3b3Jrc19hdXRob3IgPC0gdW5saXN0KGxhcHBseSh3b3JrcywgZnVuY3Rpb24obCkgbCRhdXRob3IpLCByZWN1cnNpdmUgPSBGQUxTRSkKd29ya3NfeWVhciA8LSB1bmxpc3QobGFwcGx5KHdvcmtzLCBmdW5jdGlvbihsKSBsJHB1YmxpY2F0aW9uX3llYXIpLCByZWN1cnNpdmUgPSBGQUxTRSkKCmRmX3dvcmtzIDwtIHRpYmJsZSh3b3Jrc19pZCwgd29ya3NfYXV0aG9yLCB3b3Jrc195ZWFyKQoKZHVwcyA8LSB3aGljaChkdXBsaWNhdGVkKHdvcmtzX2lkKSkKCmRmX3dvcmtzIDwtIGRmX3dvcmtzWy1kdXBzLCBdCmRmX3dvcmtzX3cyIDwtIGRmX3dvcmtzW2RmX3dvcmtzJHdvcmtzX3llYXIgPiAyMDE5LCBdCgojIHVuZGlyZWN0ZWQKIyB1bmRpcmVjdGVkCmZvciAoaSBpbiAxOm5yb3coZGZfd29ya3NfdzIpKSB7CiAgICBlZ29zIDwtIGRmX3dvcmtzX3cyJHdvcmtzX2F1dGhvcltpXVtbMV1dJGF1X2lkCgogICAgaWYgKHN1bShpZHMgJWluJSBlZ29zKSA+IDApIHsKICAgICAgICB3YXZlMlt3aGljaChpZHMgJWluJSBlZ29zKSwgd2hpY2goaWRzICVpbiUgZWdvcyldIDwtIDEKICAgIH0KfQpgYGAKPGJyPgoKTm93IG9uZSBmdW5jdGlvbiB0byBydWxlIHRoZW0gYWxsOgoKYGBge3J9CmZjb2xuZXQgPC0gZnVuY3Rpb24oZGF0YSA9IHNjaG9sYXJzLCB1bml2ZXJzaXR5ID0gIlJVIiwgZGlzY2lwbGluZSA9ICJzb2Npb2xvZ3kiLCB3YXZlcyA9IGxpc3QoYygyMDE1LAogICAgMjAxOCksIGMoMjAxOSwgMjAyMykpLCB0eXBlID0gYygiZmlyc3QiKSkgewoKICAgICMgc3RlcCAxCiAgICBkZW1vZ3JhcGhpY3MgPC0gZG8uY2FsbChyYmluZC5kYXRhLmZyYW1lLCBkYXRhJGRlbW9ncmFwaGljcykKICAgIGRlbW9ncmFwaGljcyA8LSBkZW1vZ3JhcGhpY3MgJT4lCiAgICAgICAgbXV0YXRlKFVuaXZlcnNpdGVpdDEuMjIgPSByZXBsYWNlKFVuaXZlcnNpdGVpdDEuMjIsIGlzLm5hKFVuaXZlcnNpdGVpdDEuMjIpLCAiIiksIFVuaXZlcnNpdGVpdDIuMjIgPSByZXBsYWNlKFVuaXZlcnNpdGVpdDIuMjIsCiAgICAgICAgICAgIGlzLm5hKFVuaXZlcnNpdGVpdDIuMjIpLCAiIiksIFVuaXZlcnNpdGVpdDEuMjQgPSByZXBsYWNlKFVuaXZlcnNpdGVpdDEuMjQsIGlzLm5hKFVuaXZlcnNpdGVpdDEuMjQpLAogICAgICAgICAgICAiIiksIFVuaXZlcnNpdGVpdDIuMjQgPSByZXBsYWNlKFVuaXZlcnNpdGVpdDIuMjQsIGlzLm5hKFVuaXZlcnNpdGVpdDIuMjQpLCAiIiksIGRpc2NpcGxpbmUuMjIgPSByZXBsYWNlKGRpc2NpcGxpbmUuMjIsCiAgICAgICAgICAgIGlzLm5hKGRpc2NpcGxpbmUuMjIpLCAiIiksIGRpc2NpcGxpbmUuMjQgPSByZXBsYWNlKGRpc2NpcGxpbmUuMjQsIGlzLm5hKGRpc2NpcGxpbmUuMjQpLCAiIikpCgogICAgc2FtcGxlIDwtIHdoaWNoKChkZW1vZ3JhcGhpY3MkVW5pdmVyc2l0ZWl0MS4yMiAlaW4lIHVuaXZlcnNpdHkgfCBkZW1vZ3JhcGhpY3MkVW5pdmVyc2l0ZWl0Mi4yMiAlaW4lCiAgICAgICAgdW5pdmVyc2l0eSB8IGRlbW9ncmFwaGljcyRVbml2ZXJzaXRlaXQxLjI0ICVpbiUgdW5pdmVyc2l0eSB8IGRlbW9ncmFwaGljcyRVbml2ZXJzaXRlaXQyLjI0ICVpbiUKICAgICAgICB1bml2ZXJzaXR5KSAmIChkZW1vZ3JhcGhpY3MkZGlzY2lwbGluZS4yMiAlaW4lIGRpc2NpcGxpbmUgfCBkZW1vZ3JhcGhpY3MkZGlzY2lwbGluZS4yNCAlaW4lIGRpc2NpcGxpbmUpKQoKICAgIGRlbW9ncmFwaGljc19zb2MgPC0gZGVtb2dyYXBoaWNzW3NhbXBsZSwgXQogICAgc2Nob2xhcnNfc2VsIDwtIGxhcHBseShzY2hvbGFycywgIlsiLCBzYW1wbGUpCgogICAgIyBzdGVwIDIKICAgIGlkcyA8LSBkZW1vZ3JhcGhpY3Nfc29jJGF1X2lkCiAgICBud2F2ZXMgPC0gbGVuZ3RoKHdhdmVzKQogICAgbmV0cyA8LSBhcnJheSgwLCBkaW0gPSBjKG53YXZlcywgbGVuZ3RoKGlkcyksIGxlbmd0aChpZHMpKSwgZGltbmFtZXMgPSBsaXN0KHdhdmUgPSAxOm53YXZlcywgaWRzLAogICAgICAgIGlkcykpCiAgICBkaW1uYW1lcyhuZXRzKQoKICAgICMgc3RlcCAzCiAgICBkZl93b3JrcyA8LSB0aWJibGUod29ya3NfaWQgPSB1bmxpc3QobGFwcGx5KHNjaG9sYXJzX3NlbCR3b3JrLCBmdW5jdGlvbihsKSBsJGlkKSksIHdvcmtzX2F1dGhvciA9IHVubGlzdChsYXBwbHkoc2Nob2xhcnNfc2VsJHdvcmssCiAgICAgICAgZnVuY3Rpb24obCkgbCRhdXRob3IpLCByZWN1cnNpdmUgPSBGQUxTRSksIHdvcmtzX3llYXIgPSB1bmxpc3QobGFwcGx5KHNjaG9sYXJzX3NlbCR3b3JrLCBmdW5jdGlvbihsKSBsJHB1YmxpY2F0aW9uX3llYXIpLAogICAgICAgIHJlY3Vyc2l2ZSA9IEZBTFNFKSkKCiAgICBkZl93b3JrcyA8LSBkZl93b3Jrc1shZHVwbGljYXRlZChkZl93b3JrcyksIF0KCiAgICAjIHN0ZXAgNAogICAgaWYgKHR5cGUgPT0gImZpcnN0IikgewogICAgICAgIGZvciAoaiBpbiAxOm53YXZlcykgewogICAgICAgICAgICBkZl93b3Jrc193IDwtIGRmX3dvcmtzW2RmX3dvcmtzJHdvcmtzX3llYXIgPj0gd2F2ZXNbW2pdXVsxXSAmIGRmX3dvcmtzJHdvcmtzX3llYXIgPD0gd2F2ZXNbW2pdXVsyXSwKICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgZm9yIChpIGluIDE6bnJvdyhkZl93b3Jrc193KSkgewogICAgICAgICAgICAgICAgZWdvIDwtIGRmX3dvcmtzX3ckd29ya3NfYXV0aG9yW2ldW1sxXV0kYXVfaWRbMV0KICAgICAgICAgICAgICAgIGFsdGVycyA8LSBkZl93b3Jrc193JHdvcmtzX2F1dGhvcltpXVtbMV1dJGF1X2lkWy0xXQogICAgICAgICAgICAgICAgaWYgKHN1bShpZHMgJWluJSBlZ28pID4gMCAmIHN1bShpZHMgJWluJSBhbHRlcnMpID4gMCkgewogICAgICAgICAgICAgICAgICBuZXRzW2osIHdoaWNoKGlkcyAlaW4lIGVnbyksIHdoaWNoKGlkcyAlaW4lIGFsdGVycyldIDwtIDEKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0KCiAgICBpZiAodHlwZSA9PSAibGFzdCIpIHsKICAgICAgICBmb3IgKGogaW4gMTpud2F2ZXMpIHsKICAgICAgICAgICAgZGZfd29ya3NfdyA8LSBkZl93b3Jrc1tkZl93b3JrcyR3b3Jrc195ZWFyID49IHdhdmVzW1tqXV1bMV0gJiBkZl93b3JrcyR3b3Jrc195ZWFyIDw9IHdhdmVzW1tqXV1bMl0sCiAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgIGZvciAoaSBpbiAxOm5yb3coZGZfd29ya3NfdykpIHsKICAgICAgICAgICAgICAgIGVnbyA8LSByZXYoZGZfd29ya3NfdyR3b3Jrc19hdXRob3JbaV1bWzFdXSRhdV9pZClbMV0KICAgICAgICAgICAgICAgIGFsdGVycyA8LSByZXYoZGZfd29ya3NfdyR3b3Jrc19hdXRob3JbaV1bWzFdXSRhdV9pZClbLTFdCiAgICAgICAgICAgICAgICBpZiAoc3VtKGlkcyAlaW4lIGVnbykgPiAwICYgc3VtKGlkcyAlaW4lIGFsdGVycykgPiAwKSB7CiAgICAgICAgICAgICAgICAgIG5ldHNbaiwgd2hpY2goaWRzICVpbiUgZWdvKSwgd2hpY2goaWRzICVpbiUgYWx0ZXJzKV0gPC0gMQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQoKICAgIGlmICh0eXBlID09ICJhbGwiKSB7CiAgICAgICAgZm9yIChqIGluIDE6bndhdmVzKSB7CiAgICAgICAgICAgIGRmX3dvcmtzX3cgPC0gZGZfd29ya3NbZGZfd29ya3Mkd29ya3NfeWVhciA+PSB3YXZlc1tbal1dWzFdICYgZGZfd29ya3Mkd29ya3NfeWVhciA8PSB3YXZlc1tbal1dWzJdLAogICAgICAgICAgICAgICAgXQogICAgICAgICAgICBmb3IgKGkgaW4gMTpucm93KGRmX3dvcmtzX3cpKSB7CiAgICAgICAgICAgICAgICBlZ29zIDwtIGRmX3dvcmtzX3ckd29ya3NfYXV0aG9yW2ldW1sxXV0kYXVfaWQKICAgICAgICAgICAgICAgIGlmIChzdW0oaWRzICVpbiUgZWdvcykgPiAwKSB7CiAgICAgICAgICAgICAgICAgIG5ldHNbaiwgd2hpY2goaWRzICVpbiUgZWdvcyksIHdoaWNoKGlkcyAlaW4lIGVnb3MpXSA8LSAxCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9CiAgICBvdXRwdXQgPC0gbGlzdCgpCiAgICBvdXRwdXQkZGF0YSA8LSBzY2hvbGFyc19zZWwKICAgIG91dHB1dCRuZXRzIDwtIG5ldHMKICAgIHJldHVybihvdXRwdXQpCn0KYGBgCgoKIyMjIEFzc2lnbmluZyBHZW5kZXIgdG8gZGVtb2dyYXBoaWNzCmBgYHtyfQoKZGZfc2Nob2xhcnMgPC0gZG8uY2FsbChyYmluZCwgc2Nob2xhcnMkZGVtb2dyYXBoaWNzKQoKI1ZpZXcoZGZfc2Nob2xhcnMpCgpkZl9zY2hvbGFyczIgPC0gZGZfc2Nob2xhcnMgfD4KICBtdXRhdGUoZmlyc3RuYW1lID0gd29yZChOYWFtLCAxKSkgICMgZXh0cmFjdCBmaXJzdCBuYW1lcwoKZGZfc2Nob2xhcnMyJGdlbmRlciA8LSBOQV9jaGFyYWN0ZXJfICAjIGluaXRpYWxpemUgZ2VuZGVyIGNvbHVtbgoKZm9yIChpIGluIHNlcV9sZW4obnJvdyhkZl9zY2hvbGFyczIpKSkgewogIG5hbWUgPC0gZGZfc2Nob2xhcnMyJGZpcnN0bmFtZVtpXQogIGdlbmRlciA8LSBteV9nZW5kZXJpemVyKG5hbWUpCiAgCiAgZGZfc2Nob2xhcnMyJGdlbmRlcltpXSA8LSBnZW5kZXIKICBTeXMuc2xlZXAoMC4wNikgICMgcGF1c2UgYmV0d2VlbiByZXF1ZXN0cwp9CgojVmlldyhkZl9zY2hvbGFyczIpCgpgYGAKCjxicj4KCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyMgVGh1cnNkYXkgT2t0b2JlciAybmQKCjxicj4KCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyMjIEFkZCBnZW5kZXIgZGVtb2dyYXBoaWNzIHRvIHRoZSBiaWcgZGF0YQoKTm93IGFkZCB0aGUgbmV3IGRlbW9ncmFwaGljcyBpbmNsdWRpbmcgZ2VuZGVyIHRvIHRoZSBiaWcgZGF0YQoKYGBge3J9CmZjb2xuZXRfZ2VuZGVyIDwtIGZ1bmN0aW9uKGRhdGEgPSBzY2hvbGFycywKICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pdmVyc2l0eSA9ICJSVSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2NpcGxpbmUgPSAic29jaW9sb2d5IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgd2F2ZXMgPSBsaXN0KGMoMjAxNSwgMjAxOCksIGMoMjAxOSwgMjAyMykpLAogICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gYygiZmlyc3QiKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVtb2dyYXBoaWNzID0gTlVMTCkgewogIAogICMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogICMgU3RlcCAxOiBkZW1vZ3JhcGhpY3MKICAjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICBpZiAoaXMubnVsbChkZW1vZ3JhcGhpY3MpKSB7CiAgICBkZW1vZ3JhcGhpY3MgPC0gZG8uY2FsbChyYmluZC5kYXRhLmZyYW1lLCBkYXRhJGRlbW9ncmFwaGljcykKICB9CiAgCiAgZGVtb2dyYXBoaWNzIDwtIGRlbW9ncmFwaGljcyAlPiUKICAgIG11dGF0ZSgKICAgICAgVW5pdmVyc2l0ZWl0MS4yMiA9IHJlcGxhY2UoVW5pdmVyc2l0ZWl0MS4yMiwgaXMubmEoVW5pdmVyc2l0ZWl0MS4yMiksICIiKSwKICAgICAgVW5pdmVyc2l0ZWl0Mi4yMiA9IHJlcGxhY2UoVW5pdmVyc2l0ZWl0Mi4yMiwgaXMubmEoVW5pdmVyc2l0ZWl0Mi4yMiksICIiKSwKICAgICAgVW5pdmVyc2l0ZWl0MS4yNCA9IHJlcGxhY2UoVW5pdmVyc2l0ZWl0MS4yNCwgaXMubmEoVW5pdmVyc2l0ZWl0MS4yNCksICIiKSwKICAgICAgVW5pdmVyc2l0ZWl0Mi4yNCA9IHJlcGxhY2UoVW5pdmVyc2l0ZWl0Mi4yNCwgaXMubmEoVW5pdmVyc2l0ZWl0Mi4yNCksICIiKSwKICAgICAgZGlzY2lwbGluZS4yMiAgICA9IHJlcGxhY2UoZGlzY2lwbGluZS4yMiwgICAgaXMubmEoZGlzY2lwbGluZS4yMiksICAgICIiKSwKICAgICAgZGlzY2lwbGluZS4yNCAgICA9IHJlcGxhY2UoZGlzY2lwbGluZS4yNCwgICAgaXMubmEoZGlzY2lwbGluZS4yNCksICAgICIiKQogICAgKQogIAogIHNhbXBsZSA8LSB3aGljaCgKICAgIChkZW1vZ3JhcGhpY3MkVW5pdmVyc2l0ZWl0MS4yMiAlaW4lIHVuaXZlcnNpdHkgfAogICAgICAgZGVtb2dyYXBoaWNzJFVuaXZlcnNpdGVpdDIuMjIgJWluJSB1bml2ZXJzaXR5IHwKICAgICAgIGRlbW9ncmFwaGljcyRVbml2ZXJzaXRlaXQxLjI0ICVpbiUgdW5pdmVyc2l0eSB8CiAgICAgICBkZW1vZ3JhcGhpY3MkVW5pdmVyc2l0ZWl0Mi4yNCAlaW4lIHVuaXZlcnNpdHkpICYKICAgICAgKGRlbW9ncmFwaGljcyRkaXNjaXBsaW5lLjIyICVpbiUgZGlzY2lwbGluZSB8CiAgICAgICAgIGRlbW9ncmFwaGljcyRkaXNjaXBsaW5lLjI0ICVpbiUgZGlzY2lwbGluZSkKICApCiAgCiAgZGVtb2dyYXBoaWNzX3NvYyA8LSBkZW1vZ3JhcGhpY3Nbc2FtcGxlLCBdCiAgc2Nob2xhcnNfc2VsIDwtIGxhcHBseShkYXRhLCAiWyIsIHNhbXBsZSkKICAKICAjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAjIFN0ZXAgMjogaW5pdGlhbGl6ZSBuZXR3b3JrIGFycmF5CiAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgaWRzIDwtIGRlbW9ncmFwaGljc19zb2MkYXVfaWQKICBud2F2ZXMgPC0gbGVuZ3RoKHdhdmVzKQogIG5ldHMgPC0gYXJyYXkoCiAgICAwLAogICAgZGltID0gYyhud2F2ZXMsIGxlbmd0aChpZHMpLCBsZW5ndGgoaWRzKSksCiAgICBkaW1uYW1lcyA9IGxpc3Qod2F2ZSA9IDE6bndhdmVzLCBpZHMsIGlkcykKICApCiAgCiAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgIyBTdGVwIDM6IHdvcmtzIGRhdGFmcmFtZQogICMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogIGRmX3dvcmtzIDwtIHRpYmJsZSgKICAgIHdvcmtzX2lkICAgICA9IHVubGlzdChsYXBwbHkoc2Nob2xhcnNfc2VsJHdvcmssIGZ1bmN0aW9uKGwpIGwkaWQpKSwKICAgIHdvcmtzX2F1dGhvciA9IHVubGlzdChsYXBwbHkoc2Nob2xhcnNfc2VsJHdvcmssIGZ1bmN0aW9uKGwpIGwkYXV0aG9yKSwgcmVjdXJzaXZlID0gRkFMU0UpLAogICAgd29ya3NfeWVhciAgID0gdW5saXN0KGxhcHBseShzY2hvbGFyc19zZWwkd29yaywgZnVuY3Rpb24obCkgbCRwdWJsaWNhdGlvbl95ZWFyKSwgcmVjdXJzaXZlID0gRkFMU0UpCiAgKQogIAogIGRmX3dvcmtzIDwtIGRmX3dvcmtzWyFkdXBsaWNhdGVkKGRmX3dvcmtzKSwgXQogIAogICMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogICMgU3RlcCA0OiBidWlsZCBuZXR3b3JrcwogICMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogIGlmICh0eXBlID09ICJmaXJzdCIpIHsKICAgIGZvciAoaiBpbiAxOm53YXZlcykgewogICAgICBkZl93b3Jrc193IDwtIGRmX3dvcmtzW2RmX3dvcmtzJHdvcmtzX3llYXIgPj0gd2F2ZXNbW2pdXVsxXSAmCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZl93b3JrcyR3b3Jrc195ZWFyIDw9IHdhdmVzW1tqXV1bMl0sIF0KICAgICAgZm9yIChpIGluIDE6bnJvdyhkZl93b3Jrc193KSkgewogICAgICAgIGVnbyA8LSBkZl93b3Jrc193JHdvcmtzX2F1dGhvcltpXVtbMV1dJGF1X2lkWzFdCiAgICAgICAgYWx0ZXJzIDwtIGRmX3dvcmtzX3ckd29ya3NfYXV0aG9yW2ldW1sxXV0kYXVfaWRbLTFdCiAgICAgICAgaWYgKHN1bShpZHMgJWluJSBlZ28pID4gMCAmIHN1bShpZHMgJWluJSBhbHRlcnMpID4gMCkgewogICAgICAgICAgbmV0c1tqLCB3aGljaChpZHMgJWluJSBlZ28pLCB3aGljaChpZHMgJWluJSBhbHRlcnMpXSA8LSAxCiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfQogIAogIGlmICh0eXBlID09ICJsYXN0IikgewogICAgZm9yIChqIGluIDE6bndhdmVzKSB7CiAgICAgIGRmX3dvcmtzX3cgPC0gZGZfd29ya3NbZGZfd29ya3Mkd29ya3NfeWVhciA+PSB3YXZlc1tbal1dWzFdICYKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRmX3dvcmtzJHdvcmtzX3llYXIgPD0gd2F2ZXNbW2pdXVsyXSwgXQogICAgICBmb3IgKGkgaW4gMTpucm93KGRmX3dvcmtzX3cpKSB7CiAgICAgICAgZWdvIDwtIHJldihkZl93b3Jrc193JHdvcmtzX2F1dGhvcltpXVtbMV1dJGF1X2lkKVsxXQogICAgICAgIGFsdGVycyA8LSByZXYoZGZfd29ya3NfdyR3b3Jrc19hdXRob3JbaV1bWzFdXSRhdV9pZClbLTFdCiAgICAgICAgaWYgKHN1bShpZHMgJWluJSBlZ28pID4gMCAmIHN1bShpZHMgJWluJSBhbHRlcnMpID4gMCkgewogICAgICAgICAgbmV0c1tqLCB3aGljaChpZHMgJWluJSBlZ28pLCB3aGljaChpZHMgJWluJSBhbHRlcnMpXSA8LSAxCiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfQogIAogIGlmICh0eXBlID09ICJhbGwiKSB7CiAgICBmb3IgKGogaW4gMTpud2F2ZXMpIHsKICAgICAgZGZfd29ya3NfdyA8LSBkZl93b3Jrc1tkZl93b3JrcyR3b3Jrc195ZWFyID49IHdhdmVzW1tqXV1bMV0gJgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGZfd29ya3Mkd29ya3NfeWVhciA8PSB3YXZlc1tbal1dWzJdLCBdCiAgICAgIGZvciAoaSBpbiAxOm5yb3coZGZfd29ya3NfdykpIHsKICAgICAgICBlZ29zIDwtIGRmX3dvcmtzX3ckd29ya3NfYXV0aG9yW2ldW1sxXV0kYXVfaWQKICAgICAgICBpZiAoc3VtKGlkcyAlaW4lIGVnb3MpID4gMCkgewogICAgICAgICAgbmV0c1tqLCB3aGljaChpZHMgJWluJSBlZ29zKSwgd2hpY2goaWRzICVpbiUgZWdvcyldIDwtIDEKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9CiAgCiAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgIyBTdGVwIDU6IG91dHB1dAogICMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogIG91dHB1dCA8LSBsaXN0KCkKICBvdXRwdXQkZGF0YSA8LSBzY2hvbGFyc19zZWwKICBvdXRwdXQkbmV0cyA8LSBuZXRzCiAgb3V0cHV0JGRlbW9ncmFwaGljcyA8LSBkZW1vZ3JhcGhpY3Nfc29jICAjIGluY2x1ZGVzIGdlbmRlciBpZiBwYXNzZWQgaW4KICAKICByZXR1cm4ob3V0cHV0KQp9CgpgYGAKCgojIyMgU2VlIGlmIGl0IHdvcmtzOgpgYGB7cn0KcmVzdWx0X2dlbmRlciA8LSBmY29sbmV0X2dlbmRlcigKICBkYXRhID0gc2Nob2xhcnMsCiAgdW5pdmVyc2l0eSA9ICJSVSIsCiAgZGlzY2lwbGluZSA9ICJzb2Npb2xvZ3kiLAogIGRlbW9ncmFwaGljcyA9IGRmX3NjaG9sYXJzMgopCgojIE5vdyB5b3UgY2FuIGFjY2VzcyBnZW5kZXIgaW5mbyBpbiB0aGUgb3V0cHV0CmhlYWQocmVzdWx0X2dlbmRlciRkZW1vZ3JhcGhpY3NbLCBjKCJhdV9pZCIsICJmaXJzdG5hbWUiLCAiZ2VuZGVyIildKQpgYGAKCiMjIyBWaXN1YWxpc2F0aW9uIG9mIHRoZSBuZXR3b3JrCgpgYGB7cn0KIyBhZGphY2VuY3kgbWF0cml4IGZvciBmaXJzdCB3YXZlLCBjYW4gZ2V0IHRoZSBzZWNvbmQgb25lIGJ5IG1ha2luZyBpdCBhIDIKYWRqX21hdCA8LSByZXN1bHRfZ2VuZGVyJG5ldHNbMSwsXQoKIyBjcmVhdGUgaWdyYXBoIG9iamVjdApnIDwtIGdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChhZGpfbWF0LCBtb2RlID0gInVuZGlyZWN0ZWQiKQoKIyBtYWtlIHN1cmUgdmVydGV4IG9yZGVyIG1hdGNoZXMgZGVtb2dyYXBoaWNzIG9yZGVyCmdlbmRlcl92ZWMgPC0gcmVzdWx0X2dlbmRlciRkZW1vZ3JhcGhpY3MkZ2VuZGVyCm5hbWVzKGdlbmRlcl92ZWMpIDwtIHJlc3VsdF9nZW5kZXIkZGVtb2dyYXBoaWNzJGF1X2lkCgojIGFzc2lnbiBnZW5kZXIgYXR0cmlidXRlIHRvIGlncmFwaApWKGcpJGdlbmRlciA8LSBnZW5kZXJfdmVjW1YoZykkbmFtZV0KCiMgSSBhbSBub3Qgc3VyZSB3aGV0aGVyIHBlb3BsZSB3aXRoIE5BIGFyZSBzdGlsbCBpbiBteSBuZXR3b3JrIHNvIEkgYWRkZWQgYSBncmV5IG9wdGlvbj8/PwpWKGcpJGNvbG9yIDwtIGlmZWxzZShWKGcpJGdlbmRlciA9PSAibWFsZSIsICJibHVlIiwKICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKFYoZykkZ2VuZGVyID09ICJmZW1hbGUiLCAib3JhbmdlIiwgImdyZXkiKSkKCiMgYXNzaWduIG5vZGUgc2l6ZSBieSBiZXR3ZWVubmVzcyBjZW50cmFsaXR5ClYoZykkc2l6ZSA8LSBpZ3JhcGg6OmJldHdlZW5uZXNzKGcsIG5vcm1hbGl6ZWQgPSBUUlVFLCBkaXJlY3RlZCA9IEZBTFNFKSAqIDYwICsgNwoKIyBmaW5hbCBwbG90CnBsb3QoCiAgZywKICB2ZXJ0ZXgubGFiZWwgPSBOQSwKICBlZGdlLmFycm93LnNpemUgPSAwLjQsCiAgbWFpbiA9ICJDby1hdXRob3JzaGlwIE5ldHdvcmsgUlUgU29jaW9sb2d5IChXYXZlIDEpIgopCgojIGFkZCBsZWdlbmQKbGVnZW5kKAogICJ0b3ByaWdodCIsCiAgbGVnZW5kID0gYygiTWVuIiwgIldvbWVuIiwgIlVua25vd24iKSwKICBjb2wgICAgPSBjKCJibHVlIiwgIm9yYW5nZSIsICJncmV5IiksCiAgcGNoICAgID0gMTksCiAgcHQuY2V4ID0gMS41LAogIGJ0eSAgICA9ICJuIgopCmBgYAoKIyMjIENhbGN1bGF0ZSB0aGUgcHJvcGVydGllcwpgYGB7cn0KCiMgbnVtYmVyIG9mIG5vZGVzIGFuZCBlZGdlcwp2Y291bnQoZykKZWNvdW50KGcpCgojIGRlbnNpdHkKZWRnZV9kZW5zaXR5KGcpCgojIGF2ZXJhZ2UgZGVncmVlCmRlZ3JlZSA8LSBpZ3JhcGg6OmRlZ3JlZShnKQptZWFuKGRlZ3JlZSkKCiMgYmV0d2Vlbm5lc3MgY2VudHJhbGl0eQpoZWFkKGlncmFwaDo6YmV0d2Vlbm5lc3MoZykpCgojIHRyYW5zaXZpdGl2aXR5OiBjbHVzdGVyaW5nCnRyYW5zaXRpdml0eShnLCB0eXBlID0gImdsb2JhbCIpCgoKYGBgCjxicj4KCkxldCdzIGlmIG1lbiBvciB3b21lbiBoYXZlIGEgaGlnaGVyIGRlZ3JlZSBvZiBjZW50cmFsaXR5OgpgYGB7cn0KIyBkZWdyZWUgb2YgZWFjaCBub2RlCmRlZyA8LSBpZ3JhcGg6OmRlZ3JlZShnLCBtb2RlID0gImFsbCIpICMgZm9yIHVuZGlyZWN0ZWQKCiMgZ2VuZGVyIGF0dHJpYnV0ZQpnZW5kZXIgPC0gVihnKSRnZW5kZXIKCiMgY29tYmluZSBpbnRvIGEgZGF0YWZyYW1lCm5ldHdvcmtfZGYgPC0gZGF0YS5mcmFtZSgKICBhdV9pZCA9IFYoZykkbmFtZSwKICBnZW5kZXIgPSBnZW5kZXIsCiAgZGVncmVlID0gZGVnCikKCm5ldHdvcmtfZGYgfD4KICBncm91cF9ieShnZW5kZXIpIHw+CiAgc3VtbWFyaXNlKAogICAgbWVhbl9kZWdyZWUgPSBtZWFuKGRlZ3JlZSksCiAgICBtZWRpYW5fZGVncmVlID0gbWVkaWFuKGRlZ3JlZSksCiAgICBtYXhfZGVncmVlID0gbWF4KGRlZ3JlZSksCiAgICBuID0gbigpCiAgKQoKYGBgCkluIHRoaXMgbmV0d29yaywgbWFsZSBzY2hvbGFycyB0ZW5kIHRvIGhhdmUgaGlnaGVyIGRlZ3JlZSBjZW50cmFsaXR5IHRoYW4gZmVtYWxlIHNjaG9sYXJzLgoKTWFueSBmZW1hbGUgbm9kZXMgYXJlIGlzb2xhdGVkIG9yIHdlYWtseSBjb25uZWN0ZWQsIHdoaWxlIG1hbGVzIGhhdmUgbW9yZSBjb2xsYWJvcmF0aW9ucy4K</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("lab4.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
